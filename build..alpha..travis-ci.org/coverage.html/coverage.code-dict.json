{"/home/travis/build/npmtest/node-npmtest-angular-jsdoc/test.js":"/* istanbul instrument in package npmtest_angular_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/lib.npmtest_angular_jsdoc.js":"/* istanbul instrument in package npmtest_angular_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_angular_jsdoc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_angular_jsdoc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-angular-jsdoc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_angular_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_angular_jsdoc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_angular_jsdoc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_angular_jsdoc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_angular_jsdoc.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_angular_jsdoc.__dirname + '/lib.npmtest_angular_jsdoc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/index.js":"'use strict';\r\n\r\nvar spawn = require('child_process').spawn;\r\nvar extend = require('util')._extend;\r\nvar path = require('path');\r\nvar Q = require('q');\r\nvar util = require(\"util\");\r\n\r\n/**\r\n * execute shell command\r\n */\r\nvar runCommand = function(cmd, args) {\r\n  var deferred = Q.defer();\r\n\r\n  console.log(\"cwd is: \" + __dirname);\r\n  console.log(\"angularJsdoc Running command\\n\", cmd, args.join(\" \"));\r\n\r\n  var child = (process.platform === \"win32\")\r\n    // For windows need to spawn a \"cmd\" instance and pass the command to it\r\n    ? spawn(\"cmd\", [\"/C\", cmd + \" \" + args.join(\" \")], { cwd: process.env.PWD, env: process.env})\r\n    : spawn(cmd, args);\r\n\r\n  var result = \"\";\r\n\r\n  child.stdout.on(\"data\", function(data) {\r\n    result += data;\r\n  });\r\n  child.stderr.on(\"data\", function(data) { result += data; });\r\n  child.stdout.on(\"end\", function() { deferred.resolve(result); });\r\n\r\n  return deferred.promise;\r\n};\r\n\r\n/**\r\n * main function\r\n */\r\nvar angularJsdoc = function(dirs, optionsArg, callback) {\r\n  optionsArg = optionsArg || {};\r\n  dirs = Array.isArray(dirs) ? dirs : dirs.split(\" \");\r\n\r\n  //default values\r\n  var command = optionsArg.command || util.format(\"node %s\", path.join(\"node_modules\", \"jsdoc\", \"jsdoc.js\"));\r\n\r\n  var options = extend({\r\n    configure: path.join(__dirname, \"common\", \"conf.json\"),\r\n    template: path.join(__dirname, \"default\"),\r\n    destination: \"docs\",\r\n    readme: 'README.md'\r\n  }, optionsArg);\r\n\r\n  // if given template a single word including dash\r\n  if (optionsArg.template && optionsArg.template.match(/^[\\w-]+$/i)) {\r\n    options.template = path.join(__dirname, optionsArg.template);\r\n  };\r\n\r\n  var args = [\r\n    '--configure', options.configure,\r\n    '--template', options.template,\r\n    '--destination', options.destination,\r\n    '--readme', options.readme\r\n  ];\r\n  args = args.concat(['--recurse']).concat(dirs);\r\n  runCommand(command, args).then(function(output) {\r\n    callback && callback(output);\r\n  });\r\n};\r\n\r\nmodule.exports = angularJsdoc;\r\n\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/gulpfile.js":"var gulp = require('gulp');\r\nvar bump = require('gulp-bump');\r\nvar shell = require('gulp-shell');\r\nvar tap = require('gulp-tap');\r\nvar gutil = require('gulp-util');\r\nvar bumpVersion = function(type) {\r\n  type = type || 'patch';\r\n  var version = '';\r\n  gulp.src(['./bower.json', './package.json'])\r\n    .pipe(bump({type: type}))\r\n    .pipe(gulp.dest('./'))\r\n    .pipe(tap(function(file, t) {\r\n      version = JSON.parse(file.contents.toString()).version;\r\n    })).on('end', function() {\r\n      var color = gutil.colors;\r\n      gulp.src('')\r\n        .pipe(shell([\r\n          'git commit --all --message \"Version ' + version + '\"',\r\n          (type != 'patch' ? 'git tag --annotate \"v' + version + '\" --message \"Version ' + version + '\"' : 'true')\r\n        ], {ignoreErrors: false}))\r\n        .pipe(tap(function() {\r\n          gutil.log(color.green(\"Version bumped to \") + color.yellow(version) + color.green(\", don't forget to push!\"));\r\n        }));\r\n    });\r\n\r\n};\r\n\r\ngulp.task('bump',       function() { bumpVersion('patch'); });\r\ngulp.task('bump:patch', function() { bumpVersion('patch'); });\r\ngulp.task('bump:minor', function() { bumpVersion('minor'); });\r\ngulp.task('bump:major', function() { bumpVersion('major'); });\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/angular-template/publish.js":"/*global env: true */\r\n'use strict';\r\n\r\nvar fs = require('jsdoc/fs');\r\nvar path = require('jsdoc/path');\r\nvar angularTemplate = require('angular-template');\r\nvar marked = require('marked');\r\nvar helper = require('jsdoc/util/templateHelper');\r\n\r\nvar templatePath;\r\nvar outdir = env.opts.destination;\r\nvar defaultModuleName = env.opts.query && env.opts.query.module;\r\nvar docFiles = env.opts.query && env.opts.query.docs.split(\",\");\r\nvar conf   = env.conf.templates || {}; //jshint ignore:line\r\n\r\nvar getDocletExamples = function(doclet) {\r\n  var examples = (doclet.examples||[]).map(function(example) {\r\n    var caption, code;\r\n\r\n    if (example.match(/^\\s*<caption>([\\s\\S]+?)<\\/caption>(\\s*[\\n\\r])([\\s\\S]+)$/i)) {\r\n      caption = RegExp.$1;\r\n      code  = RegExp.$3;\r\n    }\r\n\r\n    return {\r\n      caption: caption || '',\r\n      code: (code || example).replace(/</g,'&lt;')\r\n    };\r\n  });\r\n  return examples;\r\n};\r\n\r\nvar memberCache = {};\r\n\r\nvar getMembers = function(data, doclet){\r\n    var members = memberCache[doclet.longname];\r\n    if (typeof members === 'undefined' && doclet.kind === 'class') {\r\n        members  = memberCache[doclet.name];\r\n    }\r\n    return members || [];\r\n}\r\n\r\n// get children doclets that has member of current doclet longname\r\nvar getChildren = function(data, doclet) {\r\n\r\n  var members  = getMembers(data, doclet);\r\n  var children = {};\r\n  members.forEach(function(doclet) {\r\n    children[doclet.kind] = children[doclet.kind] || [];\r\n    children[doclet.kind].push(doclet);\r\n  });\r\n  return children;\r\n};\r\n\r\nvar hashToLink = function(doclet, hash) {\r\n  if ( !/^(#.+)/.test(hash) ) {\r\n    return hash;\r\n  } else {\r\n    var url = helper.createLink(doclet);\r\n    url = url.replace(/(#.+|$)/, hash);\r\n    return '<a href=\"' + url + '\">' + hash + '</a>';\r\n  }\r\n};\r\n\r\nvar generate = function(filepath, data) {\r\n  data.title = data.name;\r\n  data.prettyJson = JSON.stringify(data,null,'  ');\r\n  data.basePath = __dirname;\r\n  data.marked = marked;\r\n\r\n  var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n  var html = angularTemplate(layoutPath, data, {jsMode:false});\r\n  fs.writeFileSync(filepath, html, 'utf8');\r\n};\r\n\r\n// copy the template's static files to outdir\r\nvar copyStaticFiles = function() {\r\n  ['css', 'js'].forEach(function(dirName) {\r\n    var fromDir = path.join(templatePath, dirName);\r\n    var staticFiles = fs.ls(fromDir, 3);\r\n\r\n    staticFiles.forEach(function(fileName) {\r\n      var toDir = fs.toDir( fileName.replace(fromDir, path.join(outdir, dirName)) );\r\n      fs.mkPath(toDir);\r\n      fs.copyFileSync(fileName, toDir);\r\n    });\r\n  });\r\n};\r\n\r\nvar generateSourceFiles = function(sourceCodes, nav) {\r\n  fs.mkPath(path.join(outdir, \"source\"));\r\n  var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n\r\n  for (var key in sourceCodes) {\r\n    var el = sourceCodes[key];\r\n    var sourceCode = require('fs').readFileSync(path.join(el.path, el.filename), 'utf8');\r\n    var outputPath = path.join(outdir, \"source\", el.longname+\".html\");\r\n    var data = {\r\n      name: el.name,\r\n      longname: el.longname,\r\n      path: el.path,\r\n      filename: el.filename,\r\n      code: sourceCode.replace(/</g,'&lt;'),\r\n      nav: nav,\r\n      basePath: __dirname,\r\n      title: \"source : \"+el.filename\r\n    };\r\n    var html = angularTemplate(layoutPath, data);\r\n    fs.writeFileSync(outputPath, html, 'utf8');\r\n  }\r\n};\r\n\r\nvar generateTemplateFiles = function(templateCodes, nav) {\r\n  fs.mkPath(path.join(outdir, \"templates\"));\r\n\r\n  for (var key in templateCodes) {\r\n    var el = templateCodes[key];\r\n    if (fs.existsSync(el.filePath)) {\r\n      var templateHtml = require('fs').readFileSync(el.filePath, 'utf8');\r\n      var outputPath = path.join(outdir, \"templates\", el.outputName);\r\n      var data = {\r\n        name: el.name,\r\n        longname: el.longname,\r\n        path: el.filePath,\r\n        code: templateHtml.replace(/</g,'&lt;'),\r\n        nav: nav,\r\n        basePath: __dirname,\r\n        title: \"template : \"+el.templateUrl\r\n      };\r\n\r\n      var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n      var html = angularTemplate(layoutPath, data);\r\n      fs.writeFileSync(outputPath, html, 'utf8');\r\n    }\r\n  }\r\n};\r\n\r\nvar generateStaticDocuments = function(docs, nav) {\r\n  fs.mkPath(path.join(outdir, \"docs\"));\r\n\r\n  (docs||[]).forEach(function(el) {\r\n    var outputPath = path.join(outdir, el+\".html\");\r\n    var markdown = require('fs').readFileSync(el, 'utf8');\r\n    var documentData = {\r\n      nav: nav,\r\n      readme: marked(markdown),\r\n      basePath: __dirname,\r\n      title: el,\r\n    };\r\n\r\n    var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n    var html = angularTemplate(layoutPath, documentData);\r\n    fs.writeFileSync(outputPath, html, 'utf8');\r\n  });\r\n};\r\n\r\nvar generateTutorialFile = function(title, tutorial, filename) {\r\n  var layoutPath = path.join(templatePath, 'html', 'tutorial.html');\r\n  var tutorialData = {\r\n    title: title,\r\n    header: tutorial.title,\r\n    content: tutorial.parse(),\r\n    children: tutorial.children\r\n  };\r\n\r\n  var tutorialPath = path.join(outdir, filename);\r\n  var tutoriallink = function (tutorial) {\r\n    return helper.toTutorial(tutorial, null,\r\n      { tag: 'em', classname: 'disabled', prefix: 'Tutorial: ' });\r\n  };\r\n\r\n  var html = angularTemplate(layoutPath, {\r\n    basePath: __dirname,\r\n    tutorialData: tutorialData,\r\n    tutoriallink: tutoriallink\r\n  });\r\n  // yes, you can use {@link} in tutorials too!\r\n  // turn {@link foo} into <a href=\"foodoc.html\">foo</a>\r\n  html = helper.resolveLinks(html);\r\n  fs.writeFileSync(tutorialPath, html, 'utf8');\r\n};\r\n\r\nvar generateTutorialFiles = function(node) {\r\n  fs.mkPath(path.join(outdir, \"tutorials\"));\r\n\r\n  node.children.forEach(function(child) {\r\n    generateTutorialFile(\r\n        'Tutorial: ' + child.title,\r\n        child,\r\n        helper.tutorialToUrl(child.name)\r\n      );\r\n\r\n    generateTutorialFiles(child);\r\n  });\r\n};\r\n\r\n/**\r\n  @param {TAFFY} taffyData See <http://taffydb.com/>.\r\n  @param {object} opts\r\n */\r\nexports.publish = function(data, opts, tutorials) {\r\n  helper.setTutorials(tutorials);\r\n\r\n  data.sort('longname, version, since');\r\n\r\n  templatePath = opts.template;\r\n\r\n  var classes  = helper.find(data, {kind: 'class'});\r\n  var sourceCodes = {}, templateCodes = {};\r\n\r\n  classes.forEach(function(doclet) {\r\n\r\n    if (doclet.meta && doclet.kind == 'class') {\r\n      sourceCodes[doclet.name] = {\r\n        name: doclet.name,\r\n        longname: doclet.longname,\r\n        path: doclet.meta.path,\r\n        filename: doclet.meta.filename\r\n      };\r\n    }\r\n\r\n    if (doclet.ngdoc == 'directive') {\r\n      var code = fs.readFileSync(\r\n        path.join(doclet.meta.path, doclet.meta.filename), 'utf8');\r\n      var matches = code.match(/templateUrl\\s*:\\s* (.*)/);\r\n      var templateUrl = matches && matches[1];\r\n      if (templateUrl && templateUrl.indexOf('function') === -1) {\r\n        templateUrl = templateUrl.trim().replace(/['\",]/g,'');\r\n        var templatePath = templateUrl;\r\n        var templateCode =  {\r\n          name: doclet.name,\r\n          longname: doclet.longname,\r\n          filePath: templatePath,\r\n          templateUrl: templateUrl,\r\n          outputName: templateUrl.replace(/[\\/\\\\]/g,'_')\r\n        };\r\n        doclet.templateCode = templateCode;\r\n        doclet.templateUrl = path.join('templates', templateCode.outputName);\r\n        templateCodes[doclet.name] = templateCode;\r\n      }\r\n    }\r\n  });\r\n\r\n  data().each(function(doclet){\r\n    if(!doclet.memberof){\r\n      return;\r\n    }\r\n    \r\n    var cache = memberCache[doclet.memberof];\r\n    if(!cache){\r\n        memberCache[doclet.memberof] = [doclet];\r\n    } else {\r\n        cache.push(doclet);\r\n    }\r\n  });\r\n\r\n  data().each(function(doclet) {\r\n    doclet.children = getChildren(data, doclet);\r\n    doclet.examples = getDocletExamples(doclet);\r\n    doclet.jsDocUrl = helper.createLink(doclet);\r\n    doclet.tutoriallink = function (tutorial) {\r\n      return helper.toTutorial(tutorial, null,\r\n        { tag: 'em', classname: 'disabled', prefix: 'Tutorial: ' });\r\n    };\r\n\r\n    if (doclet.meta) {\r\n      if (doclet.kind == 'class') {\r\n        doclet.sourceUrl = 'source/'+\r\n                encodeURIComponent(sourceCodes[doclet.name].longname)+\r\n          \".html#line\"+doclet.meta.lineno;\r\n      } else if ( (doclet.kind == 'function' || doclet.kind == 'member') &&\r\n        sourceCodes[doclet.memberof]) {\r\n        doclet.sourceUrl = 'source/'+\r\n                encodeURIComponent(sourceCodes[doclet.memberof].longname)+\r\n          \".html#line\"+doclet.meta.lineno;\r\n      }\r\n    }\r\n\r\n    if (doclet.see) {\r\n      doclet.see.forEach(function(seeItem, i) {\r\n        doclet.see[i] = hashToLink(doclet, seeItem);\r\n      });\r\n    }\r\n  });\r\n\r\n  // build navigation\r\n  var nav = {\r\n    docs: docFiles || [],\r\n    module: {}\r\n  };\r\n  classes.forEach(function(doclet) {\r\n    var module = doclet.memberof || defaultModuleName;\r\n    var group = doclet.ngdoc || 'undefined';\r\n    nav.module[module] = nav.module[module] || {};\r\n    nav.module[module][group] = nav.module[module][group] || {};\r\n    nav.module[module][group][doclet.name] = {jsDocUrl: doclet.jsDocUrl};\r\n  });\r\n\r\n  // generate source html files\r\n  copyStaticFiles();                         // copy static files e.g., css, js\r\n  // generate source file as html\r\n  generateSourceFiles(sourceCodes, nav);\r\n  // generate static documents from env.opts.query.docs\r\n  generateStaticDocuments(docFiles, nav);\r\n  // generate tutorial files\r\n  generateTutorialFiles(tutorials);\r\n  // angular directive has its template, we make those as file\r\n  generateTemplateFiles(templateCodes, nav); // generate template file for directives\r\n\r\n  // generate jsdoc html files\r\n  classes.forEach(function(doclet) {\r\n    var jsDocPath = decodeURIComponent(doclet.jsDocUrl.replace(/#.*$/,''));\r\n    var outputPath = path.join(outdir, jsDocPath);\r\n    doclet.nav = nav;\r\n    generate(outputPath, doclet);\r\n  });\r\n\r\n  // generate index.html\r\n  if (opts.readme) {\r\n    var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n    var readmeData = {\r\n      nav: nav,\r\n      readme: opts.readme,\r\n      basePath: __dirname,\r\n      title: \"Index\"\r\n    };\r\n    var html = angularTemplate(layoutPath, readmeData, {jsMode:false});\r\n    fs.writeFileSync(path.join(outdir, 'index.html'), html, 'utf8');\r\n  }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/default/publish.js":"/*global env: true */\r\n'use strict';\r\n\r\nvar fs = require('jsdoc/fs');\r\nvar path = require('jsdoc/path');\r\nvar jsTemplate = require('js-template');\r\nvar marked = require('marked');\r\n\r\nvar helper = require('jsdoc/util/templateHelper');\r\n\r\nvar templatePath;\r\nvar outdir = env.opts.destination;\r\nvar defaultModuleName = env.opts.query && env.opts.query.module;\r\nvar docFiles = env.opts.query && env.opts.query.docs.split(\",\");\r\nvar conf   = env.conf.templates || {}; //jshint ignore:line\r\nvar toc    = {}; //table of contents\r\n\r\nvar getDocletExamples = function(doclet) {\r\n  var examples = (doclet.examples||[]).map(function(example) {\r\n    var caption, code;\r\n\r\n    if (example.match(/^\\s*<caption>([\\s\\S]+?)<\\/caption>(\\s*[\\n\\r])([\\s\\S]+)$/i)) {\r\n      caption = RegExp.$1;\r\n      code  = RegExp.$3;\r\n    }\r\n\r\n    return {\r\n      caption: caption || '',\r\n      code: (code || example).replace(/</g,'&lt;')\r\n    };\r\n  });\r\n  return examples;\r\n};\r\n\r\nvar getPathFromDoclet = function(doclet) {\r\n  if (!doclet.meta) {\r\n    return null;\r\n  } else if (doclet.meta.path && doclet.meta.path !== 'null') {\r\n    return path.join(doclet.meta.path, doclet.meta.filename);\r\n  } else {\r\n    return doclet.meta.filename;\r\n  }\r\n};\r\n\r\n// copy the template's static files to outdir\r\nvar copyStaticFiles = function() {\r\n  ['css', 'js', 'fonts'].forEach(function(dirName) {\r\n    var fromDir = path.join(templatePath, dirName);\r\n    var staticFiles = fs.ls(fromDir, 3);\r\n\r\n    staticFiles.forEach(function(fileName) {\r\n      var toDir = fs.toDir( fileName.replace(fromDir, path.join(outdir, dirName)) );\r\n      fs.mkPath(toDir);\r\n      fs.copyFileSync(fileName, toDir);\r\n    });\r\n  });\r\n};\r\n\r\n// get children doclets that has member of current doclet longname\r\nvar getChildren = function(data, doclet) {\r\n  var members  = helper.find(data, {memberof: doclet.longname});\r\n  if (members.length === 0 && doclet.kind === 'class') {\r\n    members  = helper.find(data, {memberof: doclet.name});\r\n  }\r\n  var children = {};\r\n  members.forEach(function(doclet) {\r\n    children[doclet.kind] = children[doclet.kind] || [];\r\n    children[doclet.kind].push(doclet);\r\n  });\r\n  return children;\r\n};\r\n\r\nvar hashToLink = function(doclet, hash) {\r\n  if ( !/^(#.+)/.test(hash) ) {\r\n    return hash;\r\n  } else {\r\n    var url = helper.createLink(doclet);\r\n    url = url.replace(/(#.+|$)/, hash);\r\n    return '<a href=\"' + url + '\">' + hash + '</a>';\r\n  }\r\n};\r\n\r\nvar generate = function(filepath, data) {\r\n  data.title = data.ngdoc + \":\" + data.longname;\r\n  data.prettyJson = JSON.stringify(data,null,'  ');\r\n  data.basePath = __dirname;\r\n  data.marked = marked;\r\n\r\n  var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n  var layoutHtml = require('fs').readFileSync(layoutPath, 'utf8');\r\n  var html = jsTemplate(layoutHtml, data);\r\n  fs.writeFileSync(filepath, html, 'utf8');\r\n};\r\n\r\nvar generateSourceFiles = function(sourceFiles, nav) {\r\n  fs.mkPath(path.join(outdir, \"source\"));\r\n  var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n  var layoutHtml = require('fs').readFileSync(layoutPath, 'utf8');\r\n  for(var jsDoc in sourceFiles) {\r\n    var source = sourceFiles[jsDoc];\r\n    var sourceCode = require('fs').readFileSync(source.path, 'utf8');\r\n    sourceCode = sourceCode.replace(/</g,\"&lt;\");\r\n    var data = {\r\n      path: source.path,\r\n      code: sourceCode,\r\n      nav: nav,\r\n      basePath: __dirname,\r\n      title: \"Source:\"+source.path.replace(/^.*[\\/\\\\]/,'')\r\n    };\r\n    var outputPath = path.join(outdir, \"source\", jsDoc);\r\n    var html = jsTemplate(layoutHtml, data);\r\n    fs.writeFileSync(outputPath, html, 'utf8');\r\n  }\r\n};\r\n\r\nvar generateStaticDocuments = function(docs, nav) {\r\n  fs.mkPath(path.join(outdir, \"docs\"));\r\n\r\n  (docs||[]).forEach(function(el) {\r\n    var outputPath = path.join(outdir, el+\".html\");\r\n    var markdown = require('fs').readFileSync(el, 'utf8');\r\n    var documentData = {\r\n      nav: nav,\r\n      readme: marked(markdown),\r\n      basePath: __dirname,\r\n      title: el,\r\n    };\r\n\r\n    var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n    var layoutHtml = require('fs').readFileSync(layoutPath, 'utf8');\r\n    var html = jsTemplate(layoutHtml, documentData);\r\n    fs.writeFileSync(outputPath, html, 'utf8');\r\n  });\r\n};\r\n\r\nvar generateTutorialFile = function(title, tutorial, filename) {\r\n  var tutorialData = {\r\n    title: title,\r\n    header: tutorial.title,\r\n    content: tutorial.parse(),\r\n    children: tutorial.children\r\n  };\r\n\r\n  var tutorialPath = path.join(outdir, filename);\r\n  var tutoriallink = function (tutorial) {\r\n    return helper.toTutorial(tutorial, null,\r\n      { tag: 'em', classname: 'disabled', prefix: 'Tutorial: ' });\r\n  };\r\n\r\n  var layoutPath = path.join(templatePath, 'html', 'tutorial.html');\r\n  var layoutHtml = require('fs').readFileSync(layoutPath, 'utf8');\r\n  var html = jsTemplate(layoutHtml, {\r\n    basePath: __dirname,\r\n    tutorialData: tutorialData,\r\n    tutoriallink: tutoriallink\r\n  });\r\n  // yes, you can use {@link} in tutorials too!\r\n  // turn {@link foo} into <a href=\"foodoc.html\">foo</a>\r\n  html = helper.resolveLinks(html);\r\n  fs.writeFileSync(tutorialPath, html, 'utf8');\r\n};\r\n\r\nvar generateTutorialFiles = function(node) {\r\n  fs.mkPath(path.join(outdir, \"tutorials\"));\r\n\r\n  node.children.forEach(function(child) {\r\n    generateTutorialFile(\r\n        'Tutorial: ' + child.title,\r\n        child,\r\n        helper.tutorialToUrl(child.name)\r\n      );\r\n\r\n    generateTutorialFiles(child);\r\n  });\r\n};\r\n\r\n/**\r\n  @param {TAFFY} taffyData See <http://taffydb.com/>.\r\n  @param {object} opts\r\n */\r\nexports.publish = function(data, opts, tutorials) {\r\n  helper.setTutorials(tutorials);\r\n  data.sort('longname, version, since');\r\n\r\n  templatePath = opts.template;\r\n  var sourceFiles = {};\r\n\r\n  data().each(function(doclet) {\r\n    doclet.children = getChildren(data, doclet);\r\n    doclet.examples = getDocletExamples(doclet);\r\n\r\n    doclet.jsDocUrl = helper.createLink(doclet);\r\n    doclet.tutoriallink = function (tutorial) {\r\n      return helper.toTutorial(tutorial, null,\r\n        { tag: 'em', classname: 'disabled', prefix: 'Tutorial: ' });\r\n    };\r\n\r\n    if (doclet.meta) {\r\n      var sourceHtml = doclet.jsDocUrl.replace(/#.*$/,'');\r\n      doclet.sourceUrl = 'source/'+sourceHtml+\"#line\"+doclet.meta.lineno;\r\n      if (doclet.kind == 'class') {\r\n        sourceFiles[sourceHtml] = {\r\n          path: getPathFromDoclet(doclet),\r\n          toc: toc\r\n        };\r\n      }\r\n    }\r\n\r\n    if (doclet.see) {\r\n      doclet.see.forEach(function(seeItem, i) {\r\n        doclet.see[i] = hashToLink(doclet, seeItem);\r\n      });\r\n    }\r\n  });\r\n\r\n  var classes  = helper.find(data, {kind: 'class'});\r\n\r\n  // build navigation\r\n  var nav = {\r\n    docs: docFiles || [],\r\n  };\r\n  classes.forEach(function(doclet) {\r\n    var module = doclet.memberof || defaultModuleName;\r\n    var group = doclet.ngdoc || 'undefined';\r\n    nav[module] = nav[module] || {};\r\n    nav[module][group] = nav[module][group] || {};\r\n    nav[module][group][doclet.longname] = {jsDocUrl: doclet.jsDocUrl};\r\n  });\r\n\r\n  // generate source html files\r\n  copyStaticFiles();                     //copy static files e.g., css, js\r\n  generateSourceFiles(sourceFiles, nav); //generate source file as html\r\n  // generate static documents from env.opts.query.docs\r\n  generateStaticDocuments(docFiles, nav);\r\n  // generate tutorial files\r\n  generateTutorialFiles(tutorials);\r\n\r\n  // generate jsdoc html files\r\n  classes.forEach(function(doclet) {\r\n    var jsDocPath = doclet.jsDocUrl.replace(/#.*$/,'');\r\n    var outputPath = path.join(outdir, jsDocPath);\r\n    doclet.nav = nav;\r\n    generate(outputPath, doclet);\r\n  });\r\n\r\n  // generate index.html\r\n  if (opts.readme) {\r\n    var layoutPath = path.join(templatePath, 'html', 'layout.html');\r\n    var layoutHtml = require('fs').readFileSync(layoutPath, 'utf8');\r\n    var readmeData = {\r\n      nav: nav,\r\n      readme: opts.readme,\r\n      basePath: __dirname,\r\n      title: \"Index\"\r\n    };\r\n    var html = jsTemplate(layoutHtml, readmeData);\r\n    fs.writeFileSync(path.join(outdir, 'index.html'), html, 'utf8');\r\n  }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/angular-template/js/prettify.js":"// Copyright (C) 2006 Google Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n/**\r\n * @fileoverview\r\n * some functions for browser-side pretty printing of code contained in html.\r\n *\r\n * <p>\r\n * For a fairly comprehensive set of languages see the\r\n * <a href=\"http://google-code-prettify.googlecode.com/svn/trunk/README.html#langs\">README</a>\r\n * file that came with this source.  At a minimum, the lexer should work on a\r\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\r\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\r\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\r\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\r\n * <p>\r\n * Usage: <ol>\r\n * <li> include this source file in an html page via\r\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\r\n * <li> define style rules.  See the example page for examples.\r\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\r\n *    {@code class=prettyprint.}\r\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\r\n *    printer needs to do more substantial DOM manipulations to support that, so\r\n *    some css styles may not be preserved.\r\n * </ol>\r\n * That's it.  I wanted to keep the API as simple as possible, so there's no\r\n * need to specify which language the code is in, but if you wish, you can add\r\n * another class to the {@code <pre>} or {@code <code>} element to specify the\r\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\r\n * starts with \"lang-\" followed by a file extension, specifies the file type.\r\n * See the \"lang-*.js\" files in this directory for code that implements\r\n * per-language file handlers.\r\n * <p>\r\n * Change log:<br>\r\n * cbeust, 2006/08/22\r\n * <blockquote>\r\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\r\n * </blockquote>\r\n * @requires console\r\n */\r\n\r\n// JSLint declarations\r\n/*global console, document, navigator, setTimeout, window, define */\r\n\r\n/** @define {boolean} */\r\nvar IN_GLOBAL_SCOPE = true;\r\n\r\n/**\r\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\r\n * UI events.\r\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\r\n */\r\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\r\n\r\n/**\r\n * Pretty print a chunk of code.\r\n * @param {string} sourceCodeHtml The HTML to pretty print.\r\n * @param {string} opt_langExtension The language name to use.\r\n *     Typically, a filename extension like 'cpp' or 'java'.\r\n * @param {number|boolean} opt_numberLines True to number lines,\r\n *     or the 1-indexed number of the first line in sourceCodeHtml.\r\n * @return {string} code as html, but prettier\r\n */\r\nvar prettyPrintOne;\r\n/**\r\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\r\n * {@code class=prettyprint} and prettify them.\r\n *\r\n * @param {Function} opt_whenDone called when prettifying is done.\r\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\r\n *   containing all the elements to pretty print.\r\n *   Defaults to {@code document.body}.\r\n */\r\nvar prettyPrint;\r\n\r\n\r\n(function () {\r\n  var win = window;\r\n  // Keyword lists for various languages.\r\n  // We use things that coerce to strings to make them compact when minified\r\n  // and to defeat aggressive optimizers that fold large string constants.\r\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\r\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" + \r\n      \"double,enum,extern,float,goto,inline,int,long,register,short,signed,\" +\r\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\r\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\r\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\r\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignof,align_union,asm,axiom,bool,\" +\r\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\r\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\r\n      \"mutable,namespace,nullptr,property,reinterpret_cast,static_assert,\" +\r\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\r\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"abstract,assert,boolean,byte,extends,final,finally,implements,import,\" +\r\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\r\n      \"throws,transient\"];\r\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,\" +\r\n      \"dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,\" +\r\n      \"internal,into,is,let,lock,null,object,out,override,orderby,params,\" +\r\n      \"partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,\" +\r\n      \"unchecked,unsafe,ushort,var,virtual,where\"];\r\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\r\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\r\n      \"throw,true,try,unless,until,when,while,yes\";\r\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"debugger,eval,export,function,get,null,set,undefined,var,with,\" +\r\n      \"Infinity,NaN\"];\r\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\r\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\r\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\r\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\r\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\r\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\r\n      \"False,True,None\"];\r\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\r\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\r\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\r\n      \"BEGIN,END\"];\r\n   var RUST_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"as,assert,const,copy,drop,\" +\r\n      \"enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,\" +\r\n      \"pub,pure,ref,self,static,struct,true,trait,type,unsafe,use\"];\r\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\r\n      \"function,in,local,set,then,until\"];\r\n  var ALL_KEYWORDS = [\r\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS,\r\n      PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\r\n  var C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\r\n\r\n  // token style names.  correspond to css classes\r\n  /**\r\n   * token style for a string literal\r\n   * @const\r\n   */\r\n  var PR_STRING = 'str';\r\n  /**\r\n   * token style for a keyword\r\n   * @const\r\n   */\r\n  var PR_KEYWORD = 'kwd';\r\n  /**\r\n   * token style for a comment\r\n   * @const\r\n   */\r\n  var PR_COMMENT = 'com';\r\n  /**\r\n   * token style for a type\r\n   * @const\r\n   */\r\n  var PR_TYPE = 'typ';\r\n  /**\r\n   * token style for a literal value.  e.g. 1, null, true.\r\n   * @const\r\n   */\r\n  var PR_LITERAL = 'lit';\r\n  /**\r\n   * token style for a punctuation string.\r\n   * @const\r\n   */\r\n  var PR_PUNCTUATION = 'pun';\r\n  /**\r\n   * token style for plain text.\r\n   * @const\r\n   */\r\n  var PR_PLAIN = 'pln';\r\n\r\n  /**\r\n   * token style for an sgml tag.\r\n   * @const\r\n   */\r\n  var PR_TAG = 'tag';\r\n  /**\r\n   * token style for a markup declaration such as a DOCTYPE.\r\n   * @const\r\n   */\r\n  var PR_DECLARATION = 'dec';\r\n  /**\r\n   * token style for embedded source.\r\n   * @const\r\n   */\r\n  var PR_SOURCE = 'src';\r\n  /**\r\n   * token style for an sgml attribute name.\r\n   * @const\r\n   */\r\n  var PR_ATTRIB_NAME = 'atn';\r\n  /**\r\n   * token style for an sgml attribute value.\r\n   * @const\r\n   */\r\n  var PR_ATTRIB_VALUE = 'atv';\r\n\r\n  /**\r\n   * A class that indicates a section of markup that is not code, e.g. to allow\r\n   * embedding of line numbers within code listings.\r\n   * @const\r\n   */\r\n  var PR_NOCODE = 'nocode';\r\n\r\n  \r\n  \r\n  /**\r\n   * A set of tokens that can precede a regular expression literal in\r\n   * javascript\r\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\r\n   * has the full list, but I've removed ones that might be problematic when\r\n   * seen in languages that don't support regular expression literals.\r\n   *\r\n   * <p>Specifically, I've removed any keywords that can't precede a regexp\r\n   * literal in a syntactically legal javascript program, and I've removed the\r\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\r\n   * as a count of inches.\r\n   *\r\n   * <p>The link above does not accurately describe EcmaScript rules since\r\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\r\n   * very well in practice.\r\n   *\r\n   * @private\r\n   * @const\r\n   */\r\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\r\n  \r\n  // CAVEAT: this does not properly handle the case where a regular\r\n  // expression immediately follows another since a regular expression may\r\n  // have flags for case-sensitivity and the like.  Having regexp tokens\r\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\r\n  // TODO: maybe style special characters inside a regexp as punctuation.\r\n\r\n  /**\r\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\r\n   * matches the union of the sets of strings matched by the input RegExp.\r\n   * Since it matches globally, if the input strings have a start-of-input\r\n   * anchor (/^.../), it is ignored for the purposes of unioning.\r\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\r\n   * @return {RegExp} a global regex.\r\n   */\r\n  function combinePrefixPatterns(regexs) {\r\n    var capturedGroupIndex = 0;\r\n  \r\n    var needToFoldCase = false;\r\n    var ignoreCase = false;\r\n    for (var i = 0, n = regexs.length; i < n; ++i) {\r\n      var regex = regexs[i];\r\n      if (regex.ignoreCase) {\r\n        ignoreCase = true;\r\n      } else if (/[a-z]/i.test(regex.source.replace(\r\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\r\n        needToFoldCase = true;\r\n        ignoreCase = false;\r\n        break;\r\n      }\r\n    }\r\n  \r\n    var escapeCharToCodeUnit = {\r\n      'b': 8,\r\n      't': 9,\r\n      'n': 0xa,\r\n      'v': 0xb,\r\n      'f': 0xc,\r\n      'r': 0xd\r\n    };\r\n  \r\n    function decodeEscape(charsetPart) {\r\n      var cc0 = charsetPart.charCodeAt(0);\r\n      if (cc0 !== 92 /* \\\\ */) {\r\n        return cc0;\r\n      }\r\n      var c1 = charsetPart.charAt(1);\r\n      cc0 = escapeCharToCodeUnit[c1];\r\n      if (cc0) {\r\n        return cc0;\r\n      } else if ('0' <= c1 && c1 <= '7') {\r\n        return parseInt(charsetPart.substring(1), 8);\r\n      } else if (c1 === 'u' || c1 === 'x') {\r\n        return parseInt(charsetPart.substring(2), 16);\r\n      } else {\r\n        return charsetPart.charCodeAt(1);\r\n      }\r\n    }\r\n  \r\n    function encodeEscape(charCode) {\r\n      if (charCode < 0x20) {\r\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\r\n      }\r\n      var ch = String.fromCharCode(charCode);\r\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\r\n          ? \"\\\\\" + ch : ch;\r\n    }\r\n  \r\n    function caseFoldCharset(charSet) {\r\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\r\n          new RegExp(\r\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\r\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\r\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\r\n              + '|\\\\\\\\[0-7]{1,2}'\r\n              + '|\\\\\\\\[\\\\s\\\\S]'\r\n              + '|-'\r\n              + '|[^-\\\\\\\\]',\r\n              'g'));\r\n      var ranges = [];\r\n      var inverse = charsetParts[0] === '^';\r\n  \r\n      var out = ['['];\r\n      if (inverse) { out.push('^'); }\r\n  \r\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\r\n        var p = charsetParts[i];\r\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\r\n          out.push(p);\r\n        } else {\r\n          var start = decodeEscape(p);\r\n          var end;\r\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\r\n            end = decodeEscape(charsetParts[i + 2]);\r\n            i += 2;\r\n          } else {\r\n            end = start;\r\n          }\r\n          ranges.push([start, end]);\r\n          // If the range might intersect letters, then expand it.\r\n          // This case handling is too simplistic.\r\n          // It does not deal with non-latin case folding.\r\n          // It works for latin source code identifiers though.\r\n          if (!(end < 65 || start > 122)) {\r\n            if (!(end < 65 || start > 90)) {\r\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\r\n            }\r\n            if (!(end < 97 || start > 122)) {\r\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\r\n      // -> [[1, 12], [14, 14], [16, 17]]\r\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\r\n      var consolidatedRanges = [];\r\n      var lastRange = [];\r\n      for (var i = 0; i < ranges.length; ++i) {\r\n        var range = ranges[i];\r\n        if (range[0] <= lastRange[1] + 1) {\r\n          lastRange[1] = Math.max(lastRange[1], range[1]);\r\n        } else {\r\n          consolidatedRanges.push(lastRange = range);\r\n        }\r\n      }\r\n  \r\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\r\n        var range = consolidatedRanges[i];\r\n        out.push(encodeEscape(range[0]));\r\n        if (range[1] > range[0]) {\r\n          if (range[1] + 1 > range[0]) { out.push('-'); }\r\n          out.push(encodeEscape(range[1]));\r\n        }\r\n      }\r\n      out.push(']');\r\n      return out.join('');\r\n    }\r\n  \r\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\r\n      // Split into character sets, escape sequences, punctuation strings\r\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\r\n      // include any of the above.\r\n      var parts = regex.source.match(\r\n          new RegExp(\r\n              '(?:'\r\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\r\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\r\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\r\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\r\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\r\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\r\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\r\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\r\n              + ')',\r\n              'g'));\r\n      var n = parts.length;\r\n  \r\n      // Maps captured group numbers to the number they will occupy in\r\n      // the output or to -1 if that has not been determined, or to\r\n      // undefined if they need not be capturing in the output.\r\n      var capturedGroups = [];\r\n  \r\n      // Walk over and identify back references to build the capturedGroups\r\n      // mapping.\r\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\r\n        var p = parts[i];\r\n        if (p === '(') {\r\n          // groups are 1-indexed, so max group index is count of '('\r\n          ++groupIndex;\r\n        } else if ('\\\\' === p.charAt(0)) {\r\n          var decimalValue = +p.substring(1);\r\n          if (decimalValue) {\r\n            if (decimalValue <= groupIndex) {\r\n              capturedGroups[decimalValue] = -1;\r\n            } else {\r\n              // Replace with an unambiguous escape sequence so that\r\n              // an octal escape sequence does not turn into a backreference\r\n              // to a capturing group from an earlier regex.\r\n              parts[i] = encodeEscape(decimalValue);\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Renumber groups and reduce capturing groups to non-capturing groups\r\n      // where possible.\r\n      for (var i = 1; i < capturedGroups.length; ++i) {\r\n        if (-1 === capturedGroups[i]) {\r\n          capturedGroups[i] = ++capturedGroupIndex;\r\n        }\r\n      }\r\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\r\n        var p = parts[i];\r\n        if (p === '(') {\r\n          ++groupIndex;\r\n          if (!capturedGroups[groupIndex]) {\r\n            parts[i] = '(?:';\r\n          }\r\n        } else if ('\\\\' === p.charAt(0)) {\r\n          var decimalValue = +p.substring(1);\r\n          if (decimalValue && decimalValue <= groupIndex) {\r\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Remove any prefix anchors so that the output will match anywhere.\r\n      // ^^ really does mean an anchored match though.\r\n      for (var i = 0; i < n; ++i) {\r\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\r\n      }\r\n  \r\n      // Expand letters to groups to handle mixing of case-sensitive and\r\n      // case-insensitive patterns if necessary.\r\n      if (regex.ignoreCase && needToFoldCase) {\r\n        for (var i = 0; i < n; ++i) {\r\n          var p = parts[i];\r\n          var ch0 = p.charAt(0);\r\n          if (p.length >= 2 && ch0 === '[') {\r\n            parts[i] = caseFoldCharset(p);\r\n          } else if (ch0 !== '\\\\') {\r\n            // TODO: handle letters in numeric escapes.\r\n            parts[i] = p.replace(\r\n                /[a-zA-Z]/g,\r\n                function (ch) {\r\n                  var cc = ch.charCodeAt(0);\r\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\r\n                });\r\n          }\r\n        }\r\n      }\r\n  \r\n      return parts.join('');\r\n    }\r\n  \r\n    var rewritten = [];\r\n    for (var i = 0, n = regexs.length; i < n; ++i) {\r\n      var regex = regexs[i];\r\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\r\n      rewritten.push(\r\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\r\n    }\r\n  \r\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\r\n  }\r\n\r\n  /**\r\n   * Split markup into a string of source code and an array mapping ranges in\r\n   * that string to the text nodes in which they appear.\r\n   *\r\n   * <p>\r\n   * The HTML DOM structure:</p>\r\n   * <pre>\r\n   * (Element   \"p\"\r\n   *   (Element \"b\"\r\n   *     (Text  \"print \"))       ; #1\r\n   *   (Text    \"'Hello '\")      ; #2\r\n   *   (Element \"br\")            ; #3\r\n   *   (Text    \"  + 'World';\")) ; #4\r\n   * </pre>\r\n   * <p>\r\n   * corresponds to the HTML\r\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\r\n   *\r\n   * <p>\r\n   * It will produce the output:</p>\r\n   * <pre>\r\n   * {\r\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\r\n   *   //                     1          2\r\n   *   //           012345678901234 5678901234567\r\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\r\n   * }\r\n   * </pre>\r\n   * <p>\r\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\r\n   * on for the other text nodes.\r\n   * </p>\r\n   *\r\n   * <p>\r\n   * The {@code} spans array is an array of pairs.  Even elements are the start\r\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\r\n   * that contain the text for those substrings.\r\n   * Substrings continue until the next index or the end of the source.\r\n   * </p>\r\n   *\r\n   * @param {Node} node an HTML DOM subtree containing source-code.\r\n   * @param {boolean} isPreformatted true if white-space in text nodes should\r\n   *    be considered significant.\r\n   * @return {Object} source code and the text nodes in which they occur.\r\n   */\r\n  function extractSourceSpans(node, isPreformatted) {\r\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\r\n  \r\n    var chunks = [];\r\n    var length = 0;\r\n    var spans = [];\r\n    var k = 0;\r\n  \r\n    function walk(node) {\r\n      var type = node.nodeType;\r\n      if (type == 1) {  // Element\r\n        if (nocode.test(node.className)) { return; }\r\n        for (var child = node.firstChild; child; child = child.nextSibling) {\r\n          walk(child);\r\n        }\r\n        var nodeName = node.nodeName.toLowerCase();\r\n        if ('br' === nodeName || 'li' === nodeName) {\r\n          chunks[k] = '\\n';\r\n          spans[k << 1] = length++;\r\n          spans[(k++ << 1) | 1] = node;\r\n        }\r\n      } else if (type == 3 || type == 4) {  // Text\r\n        var text = node.nodeValue;\r\n        if (text.length) {\r\n          if (!isPreformatted) {\r\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\r\n          } else {\r\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\r\n          }\r\n          // TODO: handle tabs here?\r\n          chunks[k] = text;\r\n          spans[k << 1] = length;\r\n          length += text.length;\r\n          spans[(k++ << 1) | 1] = node;\r\n        }\r\n      }\r\n    }\r\n  \r\n    walk(node);\r\n  \r\n    return {\r\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\r\n      spans: spans\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Apply the given language handler to sourceCode and add the resulting\r\n   * decorations to out.\r\n   * @param {number} basePos the index of sourceCode within the chunk of source\r\n   *    whose decorations are already present on out.\r\n   */\r\n  function appendDecorations(basePos, sourceCode, langHandler, out) {\r\n    if (!sourceCode) { return; }\r\n    var job = {\r\n      sourceCode: sourceCode,\r\n      basePos: basePos\r\n    };\r\n    langHandler(job);\r\n    out.push.apply(out, job.decorations);\r\n  }\r\n\r\n  var notWs = /\\S/;\r\n\r\n  /**\r\n   * Given an element, if it contains only one child element and any text nodes\r\n   * it contains contain only space characters, return the sole child element.\r\n   * Otherwise returns undefined.\r\n   * <p>\r\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\r\n   * there is a single child element that contains all the non-space textual\r\n   * content, but not to return anything where there are multiple child elements\r\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\r\n   * is textual content.\r\n   */\r\n  function childContentWrapper(element) {\r\n    var wrapper = undefined;\r\n    for (var c = element.firstChild; c; c = c.nextSibling) {\r\n      var type = c.nodeType;\r\n      wrapper = (type === 1)  // Element Node\r\n          ? (wrapper ? element : c)\r\n          : (type === 3)  // Text Node\r\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\r\n          : wrapper;\r\n    }\r\n    return wrapper === element ? undefined : wrapper;\r\n  }\r\n\r\n  /** Given triples of [style, pattern, context] returns a lexing function,\r\n    * The lexing function interprets the patterns to find token boundaries and\r\n    * returns a decoration list of the form\r\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\r\n    * where index_n is an index into the sourceCode, and style_n is a style\r\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\r\n    * all characters in sourceCode[index_n-1:index_n].\r\n    *\r\n    * The stylePatterns is a list whose elements have the form\r\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\r\n    *\r\n    * Style is a style constant like PR_PLAIN, or can be a string of the\r\n    * form 'lang-FOO', where FOO is a language extension describing the\r\n    * language of the portion of the token in $1 after pattern executes.\r\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\r\n    * '(hello (world))', then that portion of the token will be passed to the\r\n    * registered lisp handler for formatting.\r\n    * The text before and after group 1 will be restyled using this decorator\r\n    * so decorators should take care that this doesn't result in infinite\r\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\r\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\r\n    * '<script>foo()<\\/script>', which would cause the current decorator to\r\n    * be called with '<script>' which would not match the same rule since\r\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\r\n    * the generic tag rule.  The handler registered for the 'js' extension would\r\n    * then be called with 'foo()', and finally, the current decorator would\r\n    * be called with '<\\/script>' which would not match the original rule and\r\n    * so the generic tag rule would identify it as a tag.\r\n    *\r\n    * Pattern must only match prefixes, and if it matches a prefix, then that\r\n    * match is considered a token with the same style.\r\n    *\r\n    * Context is applied to the last non-whitespace, non-comment token\r\n    * recognized.\r\n    *\r\n    * Shortcut is an optional string of characters, any of which, if the first\r\n    * character, gurantee that this pattern and only this pattern matches.\r\n    *\r\n    * @param {Array} shortcutStylePatterns patterns that always start with\r\n    *   a known character.  Must have a shortcut string.\r\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\r\n    *   order if the shortcut ones fail.  May have shortcuts.\r\n    *\r\n    * @return {function (Object)} a\r\n    *   function that takes source code and returns a list of decorations.\r\n    */\r\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\r\n    var shortcuts = {};\r\n    var tokenizer;\r\n    (function () {\r\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\r\n      var allRegexs = [];\r\n      var regexKeys = {};\r\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\r\n        var patternParts = allPatterns[i];\r\n        var shortcutChars = patternParts[3];\r\n        if (shortcutChars) {\r\n          for (var c = shortcutChars.length; --c >= 0;) {\r\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\r\n          }\r\n        }\r\n        var regex = patternParts[1];\r\n        var k = '' + regex;\r\n        if (!regexKeys.hasOwnProperty(k)) {\r\n          allRegexs.push(regex);\r\n          regexKeys[k] = null;\r\n        }\r\n      }\r\n      allRegexs.push(/[\\0-\\uffff]/);\r\n      tokenizer = combinePrefixPatterns(allRegexs);\r\n    })();\r\n\r\n    var nPatterns = fallthroughStylePatterns.length;\r\n\r\n    /**\r\n     * Lexes job.sourceCode and produces an output array job.decorations of\r\n     * style classes preceded by the position at which they start in\r\n     * job.sourceCode in order.\r\n     *\r\n     * @param {Object} job an object like <pre>{\r\n     *    sourceCode: {string} sourceText plain text,\r\n     *    basePos: {int} position of job.sourceCode in the larger chunk of\r\n     *        sourceCode.\r\n     * }</pre>\r\n     */\r\n    var decorate = function (job) {\r\n      var sourceCode = job.sourceCode, basePos = job.basePos;\r\n      /** Even entries are positions in source in ascending order.  Odd enties\r\n        * are style markers (e.g., PR_COMMENT) that run from that position until\r\n        * the end.\r\n        * @type {Array.<number|string>}\r\n        */\r\n      var decorations = [basePos, PR_PLAIN];\r\n      var pos = 0;  // index into sourceCode\r\n      var tokens = sourceCode.match(tokenizer) || [];\r\n      var styleCache = {};\r\n\r\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\r\n        var token = tokens[ti];\r\n        var style = styleCache[token];\r\n        var match = void 0;\r\n\r\n        var isEmbedded;\r\n        if (typeof style === 'string') {\r\n          isEmbedded = false;\r\n        } else {\r\n          var patternParts = shortcuts[token.charAt(0)];\r\n          if (patternParts) {\r\n            match = token.match(patternParts[1]);\r\n            style = patternParts[0];\r\n          } else {\r\n            for (var i = 0; i < nPatterns; ++i) {\r\n              patternParts = fallthroughStylePatterns[i];\r\n              match = token.match(patternParts[1]);\r\n              if (match) {\r\n                style = patternParts[0];\r\n                break;\r\n              }\r\n            }\r\n\r\n            if (!match) {  // make sure that we make progress\r\n              style = PR_PLAIN;\r\n            }\r\n          }\r\n\r\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\r\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\r\n            isEmbedded = false;\r\n            style = PR_SOURCE;\r\n          }\r\n\r\n          if (!isEmbedded) { styleCache[token] = style; }\r\n        }\r\n\r\n        var tokenStart = pos;\r\n        pos += token.length;\r\n\r\n        if (!isEmbedded) {\r\n          decorations.push(basePos + tokenStart, style);\r\n        } else {  // Treat group 1 as an embedded block of source code.\r\n          var embeddedSource = match[1];\r\n          var embeddedSourceStart = token.indexOf(embeddedSource);\r\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\r\n          if (match[2]) {\r\n            // If embeddedSource can be blank, then it would match at the\r\n            // beginning which would cause us to infinitely recurse on the\r\n            // entire token, so we catch the right context in match[2].\r\n            embeddedSourceEnd = token.length - match[2].length;\r\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\r\n          }\r\n          var lang = style.substring(5);\r\n          // Decorate the left of the embedded source\r\n          appendDecorations(\r\n              basePos + tokenStart,\r\n              token.substring(0, embeddedSourceStart),\r\n              decorate, decorations);\r\n          // Decorate the embedded source\r\n          appendDecorations(\r\n              basePos + tokenStart + embeddedSourceStart,\r\n              embeddedSource,\r\n              langHandlerForExtension(lang, embeddedSource),\r\n              decorations);\r\n          // Decorate the right of the embedded section\r\n          appendDecorations(\r\n              basePos + tokenStart + embeddedSourceEnd,\r\n              token.substring(embeddedSourceEnd),\r\n              decorate, decorations);\r\n        }\r\n      }\r\n      job.decorations = decorations;\r\n    };\r\n    return decorate;\r\n  }\r\n\r\n  /** returns a function that produces a list of decorations from source text.\r\n    *\r\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\r\n    * escape.  It does not recognize perl's qq() style strings.\r\n    * It has no special handling for double delimiter escapes as in basic, or\r\n    * the tripled delimiters used in python, but should work on those regardless\r\n    * although in those cases a single string literal may be broken up into\r\n    * multiple adjacent string literals.\r\n    *\r\n    * It recognizes C, C++, and shell style comments.\r\n    *\r\n    * @param {Object} options a set of optional parameters.\r\n    * @return {function (Object)} a function that examines the source code\r\n    *     in the input job and builds the decoration list.\r\n    */\r\n  function sourceDecorator(options) {\r\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\r\n    if (options['tripleQuotedStrings']) {\r\n      // '''multi-line-string''', 'single-line-string', and double-quoted\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\r\n           null, '\\'\"']);\r\n    } else if (options['multiLineStrings']) {\r\n      // 'multi-line-string', \"multi-line-string\"\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\r\n           null, '\\'\"`']);\r\n    } else {\r\n      // 'single-line-string', \"single-line-string\"\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,\r\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\r\n           null, '\"\\'']);\r\n    }\r\n    if (options['verbatimStrings']) {\r\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\r\n      fallthroughStylePatterns.push(\r\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\r\n    }\r\n    var hc = options['hashComments'];\r\n    if (hc) {\r\n      if (options['cStyleComments']) {\r\n        if (hc > 1) {  // multiline hash comments\r\n          shortcutStylePatterns.push(\r\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\r\n        } else {\r\n          // Stop C preprocessor declarations at an unclosed open comment\r\n          shortcutStylePatterns.push(\r\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\r\n               null, '#']);\r\n        }\r\n        // #include <stdio.h>\r\n        fallthroughStylePatterns.push(\r\n            [PR_STRING,\r\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\r\n             null]);\r\n      } else {\r\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\r\n      }\r\n    }\r\n    if (options['cStyleComments']) {\r\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\r\n      fallthroughStylePatterns.push(\r\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\r\n    }\r\n    var regexLiterals = options['regexLiterals'];\r\n    if (regexLiterals) {\r\n      /**\r\n       * @const\r\n       */\r\n      var regexExcls = regexLiterals > 1\r\n        ? ''  // Multiline regex literals\r\n        : '\\n\\r';\r\n      /**\r\n       * @const\r\n       */\r\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\r\n      /**\r\n       * @const\r\n       */\r\n      var REGEX_LITERAL = (\r\n          // A regular expression literal starts with a slash that is\r\n          // not followed by * or / so that it is not confused with\r\n          // comments.\r\n          '/(?=[^/*' + regexExcls + '])'\r\n          // and then contains any number of raw characters,\r\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\r\n          // escape sequences (\\x5C),\r\n          +    '|\\\\x5C' + regexAny\r\n          // or non-nesting character sets (\\x5B\\x5D);\r\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\r\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\r\n          // finally closed by a /.\r\n          + '/');\r\n      fallthroughStylePatterns.push(\r\n          ['lang-regex',\r\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\r\n           ]);\r\n    }\r\n\r\n    var types = options['types'];\r\n    if (types) {\r\n      fallthroughStylePatterns.push([PR_TYPE, types]);\r\n    }\r\n\r\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\r\n    if (keywords.length) {\r\n      fallthroughStylePatterns.push(\r\n          [PR_KEYWORD,\r\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\r\n           null]);\r\n    }\r\n\r\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\r\n\r\n    var punctuation =\r\n      // The Bash man page says\r\n\r\n      // A word is a sequence of characters considered as a single\r\n      // unit by GRUB. Words are separated by metacharacters,\r\n      // which are the following plus space, tab, and newline: { }\r\n      // | & $ ; < >\r\n      // ...\r\n      \r\n      // A word beginning with # causes that word and all remaining\r\n      // characters on that line to be ignored.\r\n\r\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\r\n      // comment but empirically\r\n      // $ echo {#}\r\n      // {#}\r\n      // $ echo \\$#\r\n      // $#\r\n      // $ echo }#\r\n      // }#\r\n\r\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\r\n\r\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\r\n      // suggests that this definition is compatible with a\r\n      // default mode that tries to use a single token definition\r\n      // to recognize both bash/python style comments and C\r\n      // preprocessor directives.\r\n\r\n      // This definition of punctuation does not include # in the list of\r\n      // follow-on exclusions, so # will not be broken before if preceeded\r\n      // by a punctuation character.  We could try to exclude # after\r\n      // [|&;<>] but that doesn't seem to cause many major problems.\r\n      // If that does turn out to be a problem, we should change the below\r\n      // when hc is truthy to include # in the run of punctuation characters\r\n      // only when not followint [|&;<>].\r\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\r\n    if (options['regexLiterals']) {\r\n      punctuation += '(?!\\s*\\/)';\r\n    }\r\n\r\n    fallthroughStylePatterns.push(\r\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\r\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\r\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\r\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\r\n        [PR_LITERAL,\r\n         new RegExp(\r\n             '^(?:'\r\n             // A hex number\r\n             + '0x[a-f0-9]+'\r\n             // or an octal or decimal number,\r\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\r\n             // possibly in scientific notation\r\n             + '(?:e[+\\\\-]?\\\\d+)?'\r\n             + ')'\r\n             // with an optional modifier like UL for unsigned long\r\n             + '[a-z]*', 'i'),\r\n         null, '0123456789'],\r\n        // Don't treat escaped quotes in bash as starting strings.\r\n        // See issue 144.\r\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\r\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\r\n\r\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\r\n  }\r\n\r\n  var decorateSource = sourceDecorator({\r\n        'keywords': ALL_KEYWORDS,\r\n        'hashComments': true,\r\n        'cStyleComments': true,\r\n        'multiLineStrings': true,\r\n        'regexLiterals': true\r\n      });\r\n\r\n  /**\r\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\r\n   * list item.\r\n   *\r\n   * @param {Node} node modified in place.  Its content is pulled into an\r\n   *     HTMLOListElement, and each line is moved into a separate list item.\r\n   *     This requires cloning elements, so the input might not have unique\r\n   *     IDs after numbering.\r\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\r\n   *     be treated as significant.\r\n   */\r\n  function numberLines(node, opt_startLineNum, isPreformatted) {\r\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\r\n    var lineBreak = /\\r\\n?|\\n/;\r\n  \r\n    var document = node.ownerDocument;\r\n  \r\n    var li = document.createElement('li');\r\n    while (node.firstChild) {\r\n      li.appendChild(node.firstChild);\r\n    }\r\n    // An array of lines.  We split below, so this is initialized to one\r\n    // un-split line.\r\n    var listItems = [li];\r\n  \r\n    function walk(node) {\r\n      var type = node.nodeType;\r\n      if (type == 1 && !nocode.test(node.className)) {  // Element\r\n        if ('br' === node.nodeName) {\r\n          breakAfter(node);\r\n          // Discard the <BR> since it is now flush against a </LI>.\r\n          if (node.parentNode) {\r\n            node.parentNode.removeChild(node);\r\n          }\r\n        } else {\r\n          for (var child = node.firstChild; child; child = child.nextSibling) {\r\n            walk(child);\r\n          }\r\n        }\r\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\r\n        var text = node.nodeValue;\r\n        var match = text.match(lineBreak);\r\n        if (match) {\r\n          var firstLine = text.substring(0, match.index);\r\n          node.nodeValue = firstLine;\r\n          var tail = text.substring(match.index + match[0].length);\r\n          if (tail) {\r\n            var parent = node.parentNode;\r\n            parent.insertBefore(\r\n              document.createTextNode(tail), node.nextSibling);\r\n          }\r\n          breakAfter(node);\r\n          if (!firstLine) {\r\n            // Don't leave blank text nodes in the DOM.\r\n            node.parentNode.removeChild(node);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Split a line after the given node.\r\n    function breakAfter(lineEndNode) {\r\n      // If there's nothing to the right, then we can skip ending the line\r\n      // here, and move root-wards since splitting just before an end-tag\r\n      // would require us to create a bunch of empty copies.\r\n      while (!lineEndNode.nextSibling) {\r\n        lineEndNode = lineEndNode.parentNode;\r\n        if (!lineEndNode) { return; }\r\n      }\r\n  \r\n      function breakLeftOf(limit, copy) {\r\n        // Clone shallowly if this node needs to be on both sides of the break.\r\n        var rightSide = copy ? limit.cloneNode(false) : limit;\r\n        var parent = limit.parentNode;\r\n        if (parent) {\r\n          // We clone the parent chain.\r\n          // This helps us resurrect important styling elements that cross lines.\r\n          // E.g. in <i>Foo<br>Bar</i>\r\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\r\n          var parentClone = breakLeftOf(parent, 1);\r\n          // Move the clone and everything to the right of the original\r\n          // onto the cloned parent.\r\n          var next = limit.nextSibling;\r\n          parentClone.appendChild(rightSide);\r\n          for (var sibling = next; sibling; sibling = next) {\r\n            next = sibling.nextSibling;\r\n            parentClone.appendChild(sibling);\r\n          }\r\n        }\r\n        return rightSide;\r\n      }\r\n  \r\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\r\n  \r\n      // Walk the parent chain until we reach an unattached LI.\r\n      for (var parent;\r\n           // Check nodeType since IE invents document fragments.\r\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\r\n        copiedListItem = parent;\r\n      }\r\n      // Put it on the list of lines for later processing.\r\n      listItems.push(copiedListItem);\r\n    }\r\n  \r\n    // Split lines while there are lines left to split.\r\n    for (var i = 0;  // Number of lines that have been split so far.\r\n         i < listItems.length;  // length updated by breakAfter calls.\r\n         ++i) {\r\n      walk(listItems[i]);\r\n    }\r\n  \r\n    // Make sure numeric indices show correctly.\r\n    if (opt_startLineNum === (opt_startLineNum|0)) {\r\n      listItems[0].setAttribute('value', opt_startLineNum);\r\n    }\r\n  \r\n    var ol = document.createElement('ol');\r\n    ol.className = 'linenums';\r\n    var offset = Math.max(0, ((opt_startLineNum - 1 /* zero index */)) | 0) || 0;\r\n    for (var i = 0, n = listItems.length; i < n; ++i) {\r\n      li = listItems[i];\r\n      // Stick a class on the LIs so that stylesheets can\r\n      // color odd/even rows, or any other row pattern that\r\n      // is co-prime with 10.\r\n      li.className = 'L' + ((i + offset) % 10);\r\n      if (!li.firstChild) {\r\n        li.appendChild(document.createTextNode('\\xA0'));\r\n      }\r\n      ol.appendChild(li);\r\n    }\r\n  \r\n    node.appendChild(ol);\r\n  }\r\n  /**\r\n   * Breaks {@code job.sourceCode} around style boundaries in\r\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\r\n   * @param {Object} job like <pre>{\r\n   *    sourceCode: {string} source as plain text,\r\n   *    sourceNode: {HTMLElement} the element containing the source,\r\n   *    spans: {Array.<number|Node>} alternating span start indices into source\r\n   *       and the text node or element (e.g. {@code <BR>}) corresponding to that\r\n   *       span.\r\n   *    decorations: {Array.<number|string} an array of style classes preceded\r\n   *       by the position at which they start in job.sourceCode in order\r\n   * }</pre>\r\n   * @private\r\n   */\r\n  function recombineTagsAndDecorations(job) {\r\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\r\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\r\n    var newlineRe = /\\n/g;\r\n  \r\n    var source = job.sourceCode;\r\n    var sourceLength = source.length;\r\n    // Index into source after the last code-unit recombined.\r\n    var sourceIndex = 0;\r\n  \r\n    var spans = job.spans;\r\n    var nSpans = spans.length;\r\n    // Index into spans after the last span which ends at or before sourceIndex.\r\n    var spanIndex = 0;\r\n  \r\n    var decorations = job.decorations;\r\n    var nDecorations = decorations.length;\r\n    // Index into decorations after the last decoration which ends at or before\r\n    // sourceIndex.\r\n    var decorationIndex = 0;\r\n  \r\n    // Remove all zero-length decorations.\r\n    decorations[nDecorations] = sourceLength;\r\n    var decPos, i;\r\n    for (i = decPos = 0; i < nDecorations;) {\r\n      if (decorations[i] !== decorations[i + 2]) {\r\n        decorations[decPos++] = decorations[i++];\r\n        decorations[decPos++] = decorations[i++];\r\n      } else {\r\n        i += 2;\r\n      }\r\n    }\r\n    nDecorations = decPos;\r\n  \r\n    // Simplify decorations.\r\n    for (i = decPos = 0; i < nDecorations;) {\r\n      var startPos = decorations[i];\r\n      // Conflate all adjacent decorations that use the same style.\r\n      var startDec = decorations[i + 1];\r\n      var end = i + 2;\r\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\r\n        end += 2;\r\n      }\r\n      decorations[decPos++] = startPos;\r\n      decorations[decPos++] = startDec;\r\n      i = end;\r\n    }\r\n  \r\n    nDecorations = decorations.length = decPos;\r\n  \r\n    var sourceNode = job.sourceNode;\r\n    var oldDisplay;\r\n    if (sourceNode) {\r\n      oldDisplay = sourceNode.style.display;\r\n      sourceNode.style.display = 'none';\r\n    }\r\n    try {\r\n      var decoration = null;\r\n      while (spanIndex < nSpans) {\r\n        var spanStart = spans[spanIndex];\r\n        var spanEnd = spans[spanIndex + 2] || sourceLength;\r\n  \r\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\r\n  \r\n        var end = Math.min(spanEnd, decEnd);\r\n  \r\n        var textNode = spans[spanIndex + 1];\r\n        var styledText;\r\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\r\n            // Don't introduce spans around empty text nodes.\r\n            && (styledText = source.substring(sourceIndex, end))) {\r\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\r\n          // code to display with spaces instead of line breaks.\r\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\r\n          // space to appear at the beginning of every line but the first.\r\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\r\n          if (isIE8OrEarlier) {\r\n            styledText = styledText.replace(newlineRe, '\\r');\r\n          }\r\n          textNode.nodeValue = styledText;\r\n          var document = textNode.ownerDocument;\r\n          var span = document.createElement('span');\r\n          span.className = decorations[decorationIndex + 1];\r\n          var parentNode = textNode.parentNode;\r\n          parentNode.replaceChild(span, textNode);\r\n          span.appendChild(textNode);\r\n          if (sourceIndex < spanEnd) {  // Split off a text node.\r\n            spans[spanIndex + 1] = textNode\r\n                // TODO: Possibly optimize by using '' if there's no flicker.\r\n                = document.createTextNode(source.substring(end, spanEnd));\r\n            parentNode.insertBefore(textNode, span.nextSibling);\r\n          }\r\n        }\r\n  \r\n        sourceIndex = end;\r\n  \r\n        if (sourceIndex >= spanEnd) {\r\n          spanIndex += 2;\r\n        }\r\n        if (sourceIndex >= decEnd) {\r\n          decorationIndex += 2;\r\n        }\r\n      }\r\n    } finally {\r\n      if (sourceNode) {\r\n        sourceNode.style.display = oldDisplay;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Maps language-specific file extensions to handlers. */\r\n  var langHandlerRegistry = {};\r\n  /** Register a language handler for the given file extensions.\r\n    * @param {function (Object)} handler a function from source code to a list\r\n    *      of decorations.  Takes a single argument job which describes the\r\n    *      state of the computation.   The single parameter has the form\r\n    *      {@code {\r\n    *        sourceCode: {string} as plain text.\r\n    *        decorations: {Array.<number|string>} an array of style classes\r\n    *                     preceded by the position at which they start in\r\n    *                     job.sourceCode in order.\r\n    *                     The language handler should assigned this field.\r\n    *        basePos: {int} the position of source in the larger source chunk.\r\n    *                 All positions in the output decorations array are relative\r\n    *                 to the larger source chunk.\r\n    *      } }\r\n    * @param {Array.<string>} fileExtensions\r\n    */\r\n  function registerLangHandler(handler, fileExtensions) {\r\n    for (var i = fileExtensions.length; --i >= 0;) {\r\n      var ext = fileExtensions[i];\r\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\r\n        langHandlerRegistry[ext] = handler;\r\n      } else if (win['console']) {\r\n        console['warn']('cannot override language handler %s', ext);\r\n      }\r\n    }\r\n  }\r\n  function langHandlerForExtension(extension, source) {\r\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\r\n      // Treat it as markup if the first non whitespace character is a < and\r\n      // the last non-whitespace character is a >.\r\n      extension = /^\\s*</.test(source)\r\n          ? 'default-markup'\r\n          : 'default-code';\r\n    }\r\n    return langHandlerRegistry[extension];\r\n  }\r\n  registerLangHandler(decorateSource, ['default-code']);\r\n  registerLangHandler(\r\n      createSimpleLexer(\r\n          [],\r\n          [\r\n           [PR_PLAIN,       /^[^<?]+/],\r\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\r\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\r\n           // Unescaped content in an unknown language\r\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\r\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\r\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\r\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\r\n           // Unescaped content in javascript.  (Or possibly vbscript).\r\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\r\n           // Contains unescaped stylesheet content\r\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\r\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\r\n          ]),\r\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\r\n  registerLangHandler(\r\n      createSimpleLexer(\r\n          [\r\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\r\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\r\n           ],\r\n          [\r\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\r\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\r\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\r\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\r\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\r\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\r\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\r\n           ]),\r\n      ['in.tag']);\r\n  registerLangHandler(\r\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': CPP_KEYWORDS,\r\n          'hashComments': true,\r\n          'cStyleComments': true,\r\n          'types': C_TYPES\r\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': 'null,true,false'\r\n        }), ['json']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': CSHARP_KEYWORDS,\r\n          'hashComments': true,\r\n          'cStyleComments': true,\r\n          'verbatimStrings': true,\r\n          'types': C_TYPES\r\n        }), ['cs']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': JAVA_KEYWORDS,\r\n          'cStyleComments': true\r\n        }), ['java']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': SH_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true\r\n        }), ['bash', 'bsh', 'csh', 'sh']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': PYTHON_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'tripleQuotedStrings': true\r\n        }), ['cv', 'py', 'python']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': PERL_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'regexLiterals': 2  // multiline regex literals\r\n        }), ['perl', 'pl', 'pm']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': RUBY_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'regexLiterals': true\r\n        }), ['rb', 'ruby']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': JSCRIPT_KEYWORDS,\r\n          'cStyleComments': true,\r\n          'regexLiterals': true\r\n        }), ['javascript', 'js']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': COFFEE_KEYWORDS,\r\n          'hashComments': 3,  // ### style block comments\r\n          'cStyleComments': true,\r\n          'multilineStrings': true,\r\n          'tripleQuotedStrings': true,\r\n          'regexLiterals': true\r\n        }), ['coffee']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': RUST_KEYWORDS,\r\n          'cStyleComments': true,\r\n          'multilineStrings': true\r\n        }), ['rc', 'rs', 'rust']);\r\n  registerLangHandler(\r\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\r\n\r\n  function applyDecorator(job) {\r\n    var opt_langExtension = job.langExtension;\r\n\r\n    try {\r\n      // Extract tags, and convert the source code to plain text.\r\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\r\n      /** Plain text. @type {string} */\r\n      var source = sourceAndSpans.sourceCode;\r\n      job.sourceCode = source;\r\n      job.spans = sourceAndSpans.spans;\r\n      job.basePos = 0;\r\n\r\n      // Apply the appropriate language handler\r\n      langHandlerForExtension(opt_langExtension, source)(job);\r\n\r\n      // Integrate the decorations and tags back into the source code,\r\n      // modifying the sourceNode in place.\r\n      recombineTagsAndDecorations(job);\r\n    } catch (e) {\r\n      if (win['console']) {\r\n        console['log'](e && e['stack'] || e);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pretty print a chunk of code.\r\n   * @param sourceCodeHtml {string} The HTML to pretty print.\r\n   * @param opt_langExtension {string} The language name to use.\r\n   *     Typically, a filename extension like 'cpp' or 'java'.\r\n   * @param opt_numberLines {number|boolean} True to number lines,\r\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\r\n   */\r\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\r\n    var container = document.createElement('div');\r\n    // This could cause images to load and onload listeners to fire.\r\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\r\n    // We assume that the inner HTML is from a trusted source.\r\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\r\n    // when it is injected into a <pre> tag.\r\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\r\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\r\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\r\n    container = container.firstChild;\r\n    if (opt_numberLines) {\r\n      numberLines(container, opt_numberLines, true);\r\n    }\r\n\r\n    var job = {\r\n      langExtension: opt_langExtension,\r\n      numberLines: opt_numberLines,\r\n      sourceNode: container,\r\n      pre: 1\r\n    };\r\n    applyDecorator(job);\r\n    return container.innerHTML;\r\n  }\r\n\r\n   /**\r\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\r\n    * {@code class=prettyprint} and prettify them.\r\n    *\r\n    * @param {Function} opt_whenDone called when prettifying is done.\r\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\r\n    *   containing all the elements to pretty print.\r\n    *   Defaults to {@code document.body}.\r\n    */\r\n  function $prettyPrint(opt_whenDone, opt_root) {\r\n    var root = opt_root || document.body;\r\n    var doc = root.ownerDocument || document;\r\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\r\n    // fetch a list of nodes to rewrite\r\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\r\n    var elements = [];\r\n    for (var i = 0; i < codeSegments.length; ++i) {\r\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\r\n        elements.push(codeSegments[i][j]);\r\n      }\r\n    }\r\n    codeSegments = null;\r\n\r\n    var clock = Date;\r\n    if (!clock['now']) {\r\n      clock = { 'now': function () { return +(new Date); } };\r\n    }\r\n\r\n    // The loop is broken into a series of continuations to make sure that we\r\n    // don't make the browser unresponsive when rewriting a large page.\r\n    var k = 0;\r\n    var prettyPrintingJob;\r\n\r\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\r\n    var prettyPrintRe = /\\bprettyprint\\b/;\r\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\r\n    var preformattedTagNameRe = /pre|xmp/i;\r\n    var codeRe = /^code$/i;\r\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\r\n    var EMPTY = {};\r\n\r\n    function doWork() {\r\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\r\n                     clock['now']() + 250 /* ms */ :\r\n                     Infinity);\r\n      for (; k < elements.length && clock['now']() < endTime; k++) {\r\n        var cs = elements[k];\r\n\r\n        // Look for a preceding comment like\r\n        // <?prettify lang=\"...\" linenums=\"...\"?>\r\n        var attrs = EMPTY;\r\n        {\r\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\r\n            var nt = preceder.nodeType;\r\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\r\n            // like <!--?foo?-->, but in XML is a processing instruction\r\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\r\n            if (value\r\n                ? !/^\\??prettify\\b/.test(value)\r\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\r\n              // Skip over white-space text nodes but not others.\r\n              break;\r\n            }\r\n            if (value) {\r\n              attrs = {};\r\n              value.replace(\r\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\r\n                function (_, name, value) { attrs[name] = value; });\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        var className = cs.className;\r\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\r\n            // Don't redo this if we've already done it.\r\n            // This allows recalling pretty print to just prettyprint elements\r\n            // that have been added to the page since last call.\r\n            && !prettyPrintedRe.test(className)) {\r\n\r\n          // make sure this is not nested in an already prettified element\r\n          var nested = false;\r\n          for (var p = cs.parentNode; p; p = p.parentNode) {\r\n            var tn = p.tagName;\r\n            if (preCodeXmpRe.test(tn)\r\n                && p.className && prettyPrintRe.test(p.className)) {\r\n              nested = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!nested) {\r\n            // Mark done.  If we fail to prettyprint for whatever reason,\r\n            // we shouldn't try again.\r\n            cs.className += ' prettyprinted';\r\n\r\n            // If the classes includes a language extensions, use it.\r\n            // Language extensions can be specified like\r\n            //     <pre class=\"prettyprint lang-cpp\">\r\n            // the language extension \"cpp\" is used to find a language handler\r\n            // as passed to PR.registerLangHandler.\r\n            // HTML5 recommends that a language be specified using \"language-\"\r\n            // as the prefix instead.  Google Code Prettify supports both.\r\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\r\n            var langExtension = attrs['lang'];\r\n            if (!langExtension) {\r\n              langExtension = className.match(langExtensionRe);\r\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\r\n              var wrapper;\r\n              if (!langExtension && (wrapper = childContentWrapper(cs))\r\n                  && codeRe.test(wrapper.tagName)) {\r\n                langExtension = wrapper.className.match(langExtensionRe);\r\n              }\r\n\r\n              if (langExtension) { langExtension = langExtension[1]; }\r\n            }\r\n\r\n            var preformatted;\r\n            if (preformattedTagNameRe.test(cs.tagName)) {\r\n              preformatted = 1;\r\n            } else {\r\n              var currentStyle = cs['currentStyle'];\r\n              var defaultView = doc.defaultView;\r\n              var whitespace = (\r\n                  currentStyle\r\n                  ? currentStyle['whiteSpace']\r\n                  : (defaultView\r\n                     && defaultView.getComputedStyle)\r\n                  ? defaultView.getComputedStyle(cs, null)\r\n                  .getPropertyValue('white-space')\r\n                  : 0);\r\n              preformatted = whitespace\r\n                  && 'pre' === whitespace.substring(0, 3);\r\n            }\r\n\r\n            // Look for a class like linenums or linenums:<n> where <n> is the\r\n            // 1-indexed number of the first line.\r\n            var lineNums = attrs['linenums'];\r\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\r\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\r\n              lineNums =\r\n                lineNums\r\n                ? lineNums[1] && lineNums[1].length\r\n                  ? +lineNums[1] : true\r\n                : false;\r\n            }\r\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\r\n\r\n            // do the pretty printing\r\n            prettyPrintingJob = {\r\n              langExtension: langExtension,\r\n              sourceNode: cs,\r\n              numberLines: lineNums,\r\n              pre: preformatted\r\n            };\r\n            applyDecorator(prettyPrintingJob);\r\n          }\r\n        }\r\n      }\r\n      if (k < elements.length) {\r\n        // finish up in a continuation\r\n        setTimeout(doWork, 250);\r\n      } else if ('function' === typeof opt_whenDone) {\r\n        opt_whenDone();\r\n      }\r\n    }\r\n\r\n    doWork();\r\n  }\r\n\r\n  /**\r\n   * Contains functions for creating and registering new language handlers.\r\n   * @type {Object}\r\n   */\r\n  var PR = win['PR'] = {\r\n        'createSimpleLexer': createSimpleLexer,\r\n        'registerLangHandler': registerLangHandler,\r\n        'sourceDecorator': sourceDecorator,\r\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\r\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\r\n        'PR_COMMENT': PR_COMMENT,\r\n        'PR_DECLARATION': PR_DECLARATION,\r\n        'PR_KEYWORD': PR_KEYWORD,\r\n        'PR_LITERAL': PR_LITERAL,\r\n        'PR_NOCODE': PR_NOCODE,\r\n        'PR_PLAIN': PR_PLAIN,\r\n        'PR_PUNCTUATION': PR_PUNCTUATION,\r\n        'PR_SOURCE': PR_SOURCE,\r\n        'PR_STRING': PR_STRING,\r\n        'PR_TAG': PR_TAG,\r\n        'PR_TYPE': PR_TYPE,\r\n        'prettyPrintOne':\r\n           IN_GLOBAL_SCOPE\r\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\r\n             : (prettyPrintOne = $prettyPrintOne),\r\n        'prettyPrint': prettyPrint =\r\n           IN_GLOBAL_SCOPE\r\n             ? (win['prettyPrint'] = $prettyPrint)\r\n             : (prettyPrint = $prettyPrint)\r\n      };\r\n\r\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\r\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\r\n  // The Asynchronous Module Definition (AMD) API specifies a\r\n  // mechanism for defining modules such that the module and its\r\n  // dependencies can be asynchronously loaded.\r\n  // ...\r\n  // To allow a clear indicator that a global define function (as\r\n  // needed for script src browser loading) conforms to the AMD API,\r\n  // any global define function SHOULD have a property called \"amd\"\r\n  // whose value is an object. This helps avoid conflict with any\r\n  // other existing JavaScript code that could have defined a define()\r\n  // function that does not conform to the AMD API.\r\n  if (typeof define === \"function\" && define['amd']) {\r\n    define(\"google-code-prettify\", [], function () {\r\n      return PR; \r\n    });\r\n  }\r\n})();\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/angular-template/js/site.js":"// Filter UI\r\nvar tocElements = document.getElementById('toc').getElementsByTagName('a');\r\ndocument.getElementById('filter-input').addEventListener('keyup', function(e) {\r\n\r\n  var i, element;\r\n\r\n  // enter key\r\n  if (e.keyCode === 13) {\r\n    // go to the first displayed item in the toc\r\n    for (i = 0; i < tocElements.length; i++) {\r\n      element = tocElements[i];\r\n      if (!element.classList.contains('hide')) {\r\n        location.replace(element.href);\r\n        return e.preventDefault();\r\n      }\r\n    }\r\n  }\r\n\r\n  var match = function() { return true; },\r\n    value = this.value.toLowerCase();\r\n\r\n  if (!value.match(/^\\s*$/)) {\r\n    match = function(text) { return text.toLowerCase().indexOf(value) !== -1; };\r\n  }\r\n\r\n  for (i = 0; i < tocElements.length; i++) {\r\n    element = tocElements[i];\r\n    if (match(element.innerHTML)) {\r\n      element.classList.remove('hide');\r\n    } else {\r\n      element.classList.add('hide');\r\n    }\r\n  }\r\n});\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/common/plugins/ngdoc.js":"exports.defineTags = function(dictionary) {\r\n  dictionary.defineTag('ngdoc', {\r\n    mustHaveValue: true,\r\n    onTagged : function(doclet, tag) {\r\n      if (tag.value == \"method\") {\r\n        doclet.addTag('kind', 'function');\r\n      } else {\r\n        doclet.addTag('kind', 'class');\r\n      }\r\n      doclet.ngdoc = tag.value;\r\n    }\r\n  });\r\n\r\n  dictionary.defineTag('attribute', {\r\n    mustHaveValue: true,\r\n    canHaveType: true,\r\n    canHaveName: true,\r\n    onTagged: function(doclet, tag) {\r\n      doclet.attributes = parseParamTypes(doclet.attributes, tag);\r\n    }\r\n  })\r\n  .synonym('attr');\r\n\r\n  dictionary.defineTag('param', {\r\n    mustHaveValue: true,\r\n    canHaveType: true,\r\n    canHaveName: true,\r\n    onTagged: function(doclet, tag) {\r\n      doclet.params = parseParamTypes(doclet.params, tag);\r\n    }\r\n  });\r\n\r\n  dictionary.defineTag('property', {\r\n    mustHaveValue: true,\r\n    canHaveType: true,\r\n    canHaveName: true,\r\n    onTagged: function(doclet, tag) {\r\n      doclet.properties = parseParamTypes(doclet.properties, tag);\r\n    }\r\n  });\r\n\r\n  dictionary.defineTag('returns', {\r\n    mustHaveValue: false,\r\n    canHaveType: true,\r\n    canHaveName: false,\r\n    onTagged: function(doclet, tag) {\r\n      var returnsText = new RegExp(/@returns? (\\{.*\\}.*)/).exec(doclet.comment);\r\n\r\n      if (returnsText) {\r\n        tag.text = returnsText[1];\r\n        doclet.returns = parseParamTypes(doclet.returns, tag);\r\n      }\r\n    }\r\n  });\r\n\r\n  dictionary.defineTag('restrict', {\r\n    mustHaveValue: true,\r\n    onTagged: function(doclet, tag) {\r\n      var restricts={\r\n          'A': 'Attribute',\r\n          'E': 'Element',\r\n          'C': 'Class'\r\n      }\r\n      var s = tag.value.split('').map(function(aec) {\r\n        return restricts[aec];\r\n      })\r\n      doclet.restrict = s;\r\n    }\r\n  });\r\n\r\n  dictionary.defineTag('priority', {\r\n    mustHaveValue: true,\r\n    onTagged: function(doclet, tag) {\r\n      doclet.priority = tag.value;\r\n    }\r\n  });\r\n\r\n  dictionary.defineTag('eventType', {\r\n    mustHaveValue: true,\r\n    onTagged: function(doclet, tag) {\r\n      doclet.eventType = tag.value;\r\n    }\r\n  });\r\n\r\n  dictionary.defineTag('animations', {\r\n    mustHaveValue: true,\r\n    onTagged: function(doclet, tag) {\r\n      doclet.animations = tag.value;\r\n    }\r\n  });\r\n\r\n  dictionary.defineTag('scope', {\r\n    onTagged: function (doclet, tag) {\r\n      var scopeType = {\r\n        'object': 'Isolated Scope',\r\n        '{}': 'Isolated Scope',\r\n        'true': 'Child Scope',\r\n        'false': 'Shared Scope'\r\n      };\r\n\r\n      if (!scopeType.hasOwnProperty(tag.value)) {\r\n        doclet.directiveScope = 'New Scope';\r\n      } else {\r\n        doclet.directiveScope = scopeType[tag.value];\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nfunction parseParamTypes(docletParams, tag) {\r\n  if (!docletParams) {\r\n    docletParams = [];\r\n  }\r\n\r\n  var result = {\r\n    name: wrapDefaultNotation(tag),\r\n    description: tag.value.description,\r\n    optional: !!tag.value.optional,\r\n    default: tag.value.defaultvalue\r\n  };\r\n\r\n  var defaultTypes = ['boolean', 'string', 'expression', '*', 'mixed', 'number', 'null', 'undefined', 'function',\r\n    'object', 'array', 'void'];\r\n  var defaultTypeStarts = ['\\'', '\"', '[', '{'];\r\n\r\n  var typeDoc = new RegExp(/\\{(.*?)\\}/).exec(tag.text);\r\n\r\n  if (!typeDoc) {\r\n    result.typeDefinition =  '*';\r\n    docletParams.push(result);\r\n    return;\r\n  }\r\n\r\n  var types = typeDoc[1].split('|');\r\n  var typeRegex = new RegExp(/(.*?)(\\[\\])?$/);\r\n\r\n  var parseTypeDefinitionUrl = '';\r\n  var parseTypeDefinition = '';\r\n  var i = 0;\r\n  for (; i < types.length; i++) {\r\n    var type = typeRegex.exec(types[i]);\r\n\r\n    if (i > 0) {\r\n      parseTypeDefinitionUrl += '|';\r\n      parseTypeDefinition += '|';\r\n    }\r\n\r\n    if (defaultTypes.indexOf(type[1].toLowerCase()) !== -1 || defaultTypeStarts.indexOf(type[1][0]) !== -1) {\r\n      parseTypeDefinitionUrl += type[1] + (type[2] || '');\r\n    } else {\r\n      parseTypeDefinitionUrl += '<a href=\"' + type[1] + '.html\">' + type[1] + (type[2] || '') + '</a>';\r\n    }\r\n\r\n    parseTypeDefinition += type[1] + (type[2] || '');\r\n  }\r\n\r\n  result.typeDefinitionUrl = parseTypeDefinitionUrl;\r\n  result.typeDefinition = parseTypeDefinition;\r\n  docletParams.push(result);\r\n\r\n  return docletParams;\r\n}\r\n\r\nfunction wrapDefaultNotation(tag) {\r\n  var returnName = '';\r\n\r\n  if (tag.value.optional) {\r\n    returnName += '[';\r\n    returnName += tag.value.name;\r\n\r\n    if (tag.value.defaultvalue) {\r\n      returnName += '=' + tag.value.defaultvalue;\r\n    }\r\n\r\n    returnName += ']';\r\n    return returnName;\r\n  }\r\n\r\n  return tag.value.name;\r\n}","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/default/js/prettify.js":"// Copyright (C) 2006 Google Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n/**\r\n * @fileoverview\r\n * some functions for browser-side pretty printing of code contained in html.\r\n *\r\n * <p>\r\n * For a fairly comprehensive set of languages see the\r\n * <a href=\"http://google-code-prettify.googlecode.com/svn/trunk/README.html#langs\">README</a>\r\n * file that came with this source.  At a minimum, the lexer should work on a\r\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\r\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\r\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\r\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\r\n * <p>\r\n * Usage: <ol>\r\n * <li> include this source file in an html page via\r\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\r\n * <li> define style rules.  See the example page for examples.\r\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\r\n *    {@code class=prettyprint.}\r\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\r\n *    printer needs to do more substantial DOM manipulations to support that, so\r\n *    some css styles may not be preserved.\r\n * </ol>\r\n * That's it.  I wanted to keep the API as simple as possible, so there's no\r\n * need to specify which language the code is in, but if you wish, you can add\r\n * another class to the {@code <pre>} or {@code <code>} element to specify the\r\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\r\n * starts with \"lang-\" followed by a file extension, specifies the file type.\r\n * See the \"lang-*.js\" files in this directory for code that implements\r\n * per-language file handlers.\r\n * <p>\r\n * Change log:<br>\r\n * cbeust, 2006/08/22\r\n * <blockquote>\r\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\r\n * </blockquote>\r\n * @requires console\r\n */\r\n\r\n// JSLint declarations\r\n/*global console, document, navigator, setTimeout, window, define */\r\n\r\n/** @define {boolean} */\r\nvar IN_GLOBAL_SCOPE = true;\r\n\r\n/**\r\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\r\n * UI events.\r\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\r\n */\r\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\r\n\r\n/**\r\n * Pretty print a chunk of code.\r\n * @param {string} sourceCodeHtml The HTML to pretty print.\r\n * @param {string} opt_langExtension The language name to use.\r\n *     Typically, a filename extension like 'cpp' or 'java'.\r\n * @param {number|boolean} opt_numberLines True to number lines,\r\n *     or the 1-indexed number of the first line in sourceCodeHtml.\r\n * @return {string} code as html, but prettier\r\n */\r\nvar prettyPrintOne;\r\n/**\r\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\r\n * {@code class=prettyprint} and prettify them.\r\n *\r\n * @param {Function} opt_whenDone called when prettifying is done.\r\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\r\n *   containing all the elements to pretty print.\r\n *   Defaults to {@code document.body}.\r\n */\r\nvar prettyPrint;\r\n\r\n\r\n(function () {\r\n  var win = window;\r\n  // Keyword lists for various languages.\r\n  // We use things that coerce to strings to make them compact when minified\r\n  // and to defeat aggressive optimizers that fold large string constants.\r\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\r\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" + \r\n      \"double,enum,extern,float,goto,inline,int,long,register,short,signed,\" +\r\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\r\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\r\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\r\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignof,align_union,asm,axiom,bool,\" +\r\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\r\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\r\n      \"mutable,namespace,nullptr,property,reinterpret_cast,static_assert,\" +\r\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\r\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"abstract,assert,boolean,byte,extends,final,finally,implements,import,\" +\r\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\r\n      \"throws,transient\"];\r\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,\" +\r\n      \"dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,\" +\r\n      \"internal,into,is,let,lock,null,object,out,override,orderby,params,\" +\r\n      \"partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,\" +\r\n      \"unchecked,unsafe,ushort,var,virtual,where\"];\r\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\r\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\r\n      \"throw,true,try,unless,until,when,while,yes\";\r\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\r\n      \"debugger,eval,export,function,get,null,set,undefined,var,with,\" +\r\n      \"Infinity,NaN\"];\r\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\r\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\r\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\r\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\r\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\r\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\r\n      \"False,True,None\"];\r\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\r\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\r\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\r\n      \"BEGIN,END\"];\r\n   var RUST_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"as,assert,const,copy,drop,\" +\r\n      \"enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,\" +\r\n      \"pub,pure,ref,self,static,struct,true,trait,type,unsafe,use\"];\r\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\r\n      \"function,in,local,set,then,until\"];\r\n  var ALL_KEYWORDS = [\r\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS,\r\n      PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\r\n  var C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\r\n\r\n  // token style names.  correspond to css classes\r\n  /**\r\n   * token style for a string literal\r\n   * @const\r\n   */\r\n  var PR_STRING = 'str';\r\n  /**\r\n   * token style for a keyword\r\n   * @const\r\n   */\r\n  var PR_KEYWORD = 'kwd';\r\n  /**\r\n   * token style for a comment\r\n   * @const\r\n   */\r\n  var PR_COMMENT = 'com';\r\n  /**\r\n   * token style for a type\r\n   * @const\r\n   */\r\n  var PR_TYPE = 'typ';\r\n  /**\r\n   * token style for a literal value.  e.g. 1, null, true.\r\n   * @const\r\n   */\r\n  var PR_LITERAL = 'lit';\r\n  /**\r\n   * token style for a punctuation string.\r\n   * @const\r\n   */\r\n  var PR_PUNCTUATION = 'pun';\r\n  /**\r\n   * token style for plain text.\r\n   * @const\r\n   */\r\n  var PR_PLAIN = 'pln';\r\n\r\n  /**\r\n   * token style for an sgml tag.\r\n   * @const\r\n   */\r\n  var PR_TAG = 'tag';\r\n  /**\r\n   * token style for a markup declaration such as a DOCTYPE.\r\n   * @const\r\n   */\r\n  var PR_DECLARATION = 'dec';\r\n  /**\r\n   * token style for embedded source.\r\n   * @const\r\n   */\r\n  var PR_SOURCE = 'src';\r\n  /**\r\n   * token style for an sgml attribute name.\r\n   * @const\r\n   */\r\n  var PR_ATTRIB_NAME = 'atn';\r\n  /**\r\n   * token style for an sgml attribute value.\r\n   * @const\r\n   */\r\n  var PR_ATTRIB_VALUE = 'atv';\r\n\r\n  /**\r\n   * A class that indicates a section of markup that is not code, e.g. to allow\r\n   * embedding of line numbers within code listings.\r\n   * @const\r\n   */\r\n  var PR_NOCODE = 'nocode';\r\n\r\n  \r\n  \r\n  /**\r\n   * A set of tokens that can precede a regular expression literal in\r\n   * javascript\r\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\r\n   * has the full list, but I've removed ones that might be problematic when\r\n   * seen in languages that don't support regular expression literals.\r\n   *\r\n   * <p>Specifically, I've removed any keywords that can't precede a regexp\r\n   * literal in a syntactically legal javascript program, and I've removed the\r\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\r\n   * as a count of inches.\r\n   *\r\n   * <p>The link above does not accurately describe EcmaScript rules since\r\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\r\n   * very well in practice.\r\n   *\r\n   * @private\r\n   * @const\r\n   */\r\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\r\n  \r\n  // CAVEAT: this does not properly handle the case where a regular\r\n  // expression immediately follows another since a regular expression may\r\n  // have flags for case-sensitivity and the like.  Having regexp tokens\r\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\r\n  // TODO: maybe style special characters inside a regexp as punctuation.\r\n\r\n  /**\r\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\r\n   * matches the union of the sets of strings matched by the input RegExp.\r\n   * Since it matches globally, if the input strings have a start-of-input\r\n   * anchor (/^.../), it is ignored for the purposes of unioning.\r\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\r\n   * @return {RegExp} a global regex.\r\n   */\r\n  function combinePrefixPatterns(regexs) {\r\n    var capturedGroupIndex = 0;\r\n  \r\n    var needToFoldCase = false;\r\n    var ignoreCase = false;\r\n    for (var i = 0, n = regexs.length; i < n; ++i) {\r\n      var regex = regexs[i];\r\n      if (regex.ignoreCase) {\r\n        ignoreCase = true;\r\n      } else if (/[a-z]/i.test(regex.source.replace(\r\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\r\n        needToFoldCase = true;\r\n        ignoreCase = false;\r\n        break;\r\n      }\r\n    }\r\n  \r\n    var escapeCharToCodeUnit = {\r\n      'b': 8,\r\n      't': 9,\r\n      'n': 0xa,\r\n      'v': 0xb,\r\n      'f': 0xc,\r\n      'r': 0xd\r\n    };\r\n  \r\n    function decodeEscape(charsetPart) {\r\n      var cc0 = charsetPart.charCodeAt(0);\r\n      if (cc0 !== 92 /* \\\\ */) {\r\n        return cc0;\r\n      }\r\n      var c1 = charsetPart.charAt(1);\r\n      cc0 = escapeCharToCodeUnit[c1];\r\n      if (cc0) {\r\n        return cc0;\r\n      } else if ('0' <= c1 && c1 <= '7') {\r\n        return parseInt(charsetPart.substring(1), 8);\r\n      } else if (c1 === 'u' || c1 === 'x') {\r\n        return parseInt(charsetPart.substring(2), 16);\r\n      } else {\r\n        return charsetPart.charCodeAt(1);\r\n      }\r\n    }\r\n  \r\n    function encodeEscape(charCode) {\r\n      if (charCode < 0x20) {\r\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\r\n      }\r\n      var ch = String.fromCharCode(charCode);\r\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\r\n          ? \"\\\\\" + ch : ch;\r\n    }\r\n  \r\n    function caseFoldCharset(charSet) {\r\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\r\n          new RegExp(\r\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\r\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\r\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\r\n              + '|\\\\\\\\[0-7]{1,2}'\r\n              + '|\\\\\\\\[\\\\s\\\\S]'\r\n              + '|-'\r\n              + '|[^-\\\\\\\\]',\r\n              'g'));\r\n      var ranges = [];\r\n      var inverse = charsetParts[0] === '^';\r\n  \r\n      var out = ['['];\r\n      if (inverse) { out.push('^'); }\r\n  \r\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\r\n        var p = charsetParts[i];\r\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\r\n          out.push(p);\r\n        } else {\r\n          var start = decodeEscape(p);\r\n          var end;\r\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\r\n            end = decodeEscape(charsetParts[i + 2]);\r\n            i += 2;\r\n          } else {\r\n            end = start;\r\n          }\r\n          ranges.push([start, end]);\r\n          // If the range might intersect letters, then expand it.\r\n          // This case handling is too simplistic.\r\n          // It does not deal with non-latin case folding.\r\n          // It works for latin source code identifiers though.\r\n          if (!(end < 65 || start > 122)) {\r\n            if (!(end < 65 || start > 90)) {\r\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\r\n            }\r\n            if (!(end < 97 || start > 122)) {\r\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\r\n      // -> [[1, 12], [14, 14], [16, 17]]\r\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\r\n      var consolidatedRanges = [];\r\n      var lastRange = [];\r\n      for (var i = 0; i < ranges.length; ++i) {\r\n        var range = ranges[i];\r\n        if (range[0] <= lastRange[1] + 1) {\r\n          lastRange[1] = Math.max(lastRange[1], range[1]);\r\n        } else {\r\n          consolidatedRanges.push(lastRange = range);\r\n        }\r\n      }\r\n  \r\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\r\n        var range = consolidatedRanges[i];\r\n        out.push(encodeEscape(range[0]));\r\n        if (range[1] > range[0]) {\r\n          if (range[1] + 1 > range[0]) { out.push('-'); }\r\n          out.push(encodeEscape(range[1]));\r\n        }\r\n      }\r\n      out.push(']');\r\n      return out.join('');\r\n    }\r\n  \r\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\r\n      // Split into character sets, escape sequences, punctuation strings\r\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\r\n      // include any of the above.\r\n      var parts = regex.source.match(\r\n          new RegExp(\r\n              '(?:'\r\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\r\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\r\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\r\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\r\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\r\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\r\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\r\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\r\n              + ')',\r\n              'g'));\r\n      var n = parts.length;\r\n  \r\n      // Maps captured group numbers to the number they will occupy in\r\n      // the output or to -1 if that has not been determined, or to\r\n      // undefined if they need not be capturing in the output.\r\n      var capturedGroups = [];\r\n  \r\n      // Walk over and identify back references to build the capturedGroups\r\n      // mapping.\r\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\r\n        var p = parts[i];\r\n        if (p === '(') {\r\n          // groups are 1-indexed, so max group index is count of '('\r\n          ++groupIndex;\r\n        } else if ('\\\\' === p.charAt(0)) {\r\n          var decimalValue = +p.substring(1);\r\n          if (decimalValue) {\r\n            if (decimalValue <= groupIndex) {\r\n              capturedGroups[decimalValue] = -1;\r\n            } else {\r\n              // Replace with an unambiguous escape sequence so that\r\n              // an octal escape sequence does not turn into a backreference\r\n              // to a capturing group from an earlier regex.\r\n              parts[i] = encodeEscape(decimalValue);\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Renumber groups and reduce capturing groups to non-capturing groups\r\n      // where possible.\r\n      for (var i = 1; i < capturedGroups.length; ++i) {\r\n        if (-1 === capturedGroups[i]) {\r\n          capturedGroups[i] = ++capturedGroupIndex;\r\n        }\r\n      }\r\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\r\n        var p = parts[i];\r\n        if (p === '(') {\r\n          ++groupIndex;\r\n          if (!capturedGroups[groupIndex]) {\r\n            parts[i] = '(?:';\r\n          }\r\n        } else if ('\\\\' === p.charAt(0)) {\r\n          var decimalValue = +p.substring(1);\r\n          if (decimalValue && decimalValue <= groupIndex) {\r\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\r\n          }\r\n        }\r\n      }\r\n  \r\n      // Remove any prefix anchors so that the output will match anywhere.\r\n      // ^^ really does mean an anchored match though.\r\n      for (var i = 0; i < n; ++i) {\r\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\r\n      }\r\n  \r\n      // Expand letters to groups to handle mixing of case-sensitive and\r\n      // case-insensitive patterns if necessary.\r\n      if (regex.ignoreCase && needToFoldCase) {\r\n        for (var i = 0; i < n; ++i) {\r\n          var p = parts[i];\r\n          var ch0 = p.charAt(0);\r\n          if (p.length >= 2 && ch0 === '[') {\r\n            parts[i] = caseFoldCharset(p);\r\n          } else if (ch0 !== '\\\\') {\r\n            // TODO: handle letters in numeric escapes.\r\n            parts[i] = p.replace(\r\n                /[a-zA-Z]/g,\r\n                function (ch) {\r\n                  var cc = ch.charCodeAt(0);\r\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\r\n                });\r\n          }\r\n        }\r\n      }\r\n  \r\n      return parts.join('');\r\n    }\r\n  \r\n    var rewritten = [];\r\n    for (var i = 0, n = regexs.length; i < n; ++i) {\r\n      var regex = regexs[i];\r\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\r\n      rewritten.push(\r\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\r\n    }\r\n  \r\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\r\n  }\r\n\r\n  /**\r\n   * Split markup into a string of source code and an array mapping ranges in\r\n   * that string to the text nodes in which they appear.\r\n   *\r\n   * <p>\r\n   * The HTML DOM structure:</p>\r\n   * <pre>\r\n   * (Element   \"p\"\r\n   *   (Element \"b\"\r\n   *     (Text  \"print \"))       ; #1\r\n   *   (Text    \"'Hello '\")      ; #2\r\n   *   (Element \"br\")            ; #3\r\n   *   (Text    \"  + 'World';\")) ; #4\r\n   * </pre>\r\n   * <p>\r\n   * corresponds to the HTML\r\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\r\n   *\r\n   * <p>\r\n   * It will produce the output:</p>\r\n   * <pre>\r\n   * {\r\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\r\n   *   //                     1          2\r\n   *   //           012345678901234 5678901234567\r\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\r\n   * }\r\n   * </pre>\r\n   * <p>\r\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\r\n   * on for the other text nodes.\r\n   * </p>\r\n   *\r\n   * <p>\r\n   * The {@code} spans array is an array of pairs.  Even elements are the start\r\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\r\n   * that contain the text for those substrings.\r\n   * Substrings continue until the next index or the end of the source.\r\n   * </p>\r\n   *\r\n   * @param {Node} node an HTML DOM subtree containing source-code.\r\n   * @param {boolean} isPreformatted true if white-space in text nodes should\r\n   *    be considered significant.\r\n   * @return {Object} source code and the text nodes in which they occur.\r\n   */\r\n  function extractSourceSpans(node, isPreformatted) {\r\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\r\n  \r\n    var chunks = [];\r\n    var length = 0;\r\n    var spans = [];\r\n    var k = 0;\r\n  \r\n    function walk(node) {\r\n      var type = node.nodeType;\r\n      if (type == 1) {  // Element\r\n        if (nocode.test(node.className)) { return; }\r\n        for (var child = node.firstChild; child; child = child.nextSibling) {\r\n          walk(child);\r\n        }\r\n        var nodeName = node.nodeName.toLowerCase();\r\n        if ('br' === nodeName || 'li' === nodeName) {\r\n          chunks[k] = '\\n';\r\n          spans[k << 1] = length++;\r\n          spans[(k++ << 1) | 1] = node;\r\n        }\r\n      } else if (type == 3 || type == 4) {  // Text\r\n        var text = node.nodeValue;\r\n        if (text.length) {\r\n          if (!isPreformatted) {\r\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\r\n          } else {\r\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\r\n          }\r\n          // TODO: handle tabs here?\r\n          chunks[k] = text;\r\n          spans[k << 1] = length;\r\n          length += text.length;\r\n          spans[(k++ << 1) | 1] = node;\r\n        }\r\n      }\r\n    }\r\n  \r\n    walk(node);\r\n  \r\n    return {\r\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\r\n      spans: spans\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Apply the given language handler to sourceCode and add the resulting\r\n   * decorations to out.\r\n   * @param {number} basePos the index of sourceCode within the chunk of source\r\n   *    whose decorations are already present on out.\r\n   */\r\n  function appendDecorations(basePos, sourceCode, langHandler, out) {\r\n    if (!sourceCode) { return; }\r\n    var job = {\r\n      sourceCode: sourceCode,\r\n      basePos: basePos\r\n    };\r\n    langHandler(job);\r\n    out.push.apply(out, job.decorations);\r\n  }\r\n\r\n  var notWs = /\\S/;\r\n\r\n  /**\r\n   * Given an element, if it contains only one child element and any text nodes\r\n   * it contains contain only space characters, return the sole child element.\r\n   * Otherwise returns undefined.\r\n   * <p>\r\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\r\n   * there is a single child element that contains all the non-space textual\r\n   * content, but not to return anything where there are multiple child elements\r\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\r\n   * is textual content.\r\n   */\r\n  function childContentWrapper(element) {\r\n    var wrapper = undefined;\r\n    for (var c = element.firstChild; c; c = c.nextSibling) {\r\n      var type = c.nodeType;\r\n      wrapper = (type === 1)  // Element Node\r\n          ? (wrapper ? element : c)\r\n          : (type === 3)  // Text Node\r\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\r\n          : wrapper;\r\n    }\r\n    return wrapper === element ? undefined : wrapper;\r\n  }\r\n\r\n  /** Given triples of [style, pattern, context] returns a lexing function,\r\n    * The lexing function interprets the patterns to find token boundaries and\r\n    * returns a decoration list of the form\r\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\r\n    * where index_n is an index into the sourceCode, and style_n is a style\r\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\r\n    * all characters in sourceCode[index_n-1:index_n].\r\n    *\r\n    * The stylePatterns is a list whose elements have the form\r\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\r\n    *\r\n    * Style is a style constant like PR_PLAIN, or can be a string of the\r\n    * form 'lang-FOO', where FOO is a language extension describing the\r\n    * language of the portion of the token in $1 after pattern executes.\r\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\r\n    * '(hello (world))', then that portion of the token will be passed to the\r\n    * registered lisp handler for formatting.\r\n    * The text before and after group 1 will be restyled using this decorator\r\n    * so decorators should take care that this doesn't result in infinite\r\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\r\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\r\n    * '<script>foo()<\\/script>', which would cause the current decorator to\r\n    * be called with '<script>' which would not match the same rule since\r\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\r\n    * the generic tag rule.  The handler registered for the 'js' extension would\r\n    * then be called with 'foo()', and finally, the current decorator would\r\n    * be called with '<\\/script>' which would not match the original rule and\r\n    * so the generic tag rule would identify it as a tag.\r\n    *\r\n    * Pattern must only match prefixes, and if it matches a prefix, then that\r\n    * match is considered a token with the same style.\r\n    *\r\n    * Context is applied to the last non-whitespace, non-comment token\r\n    * recognized.\r\n    *\r\n    * Shortcut is an optional string of characters, any of which, if the first\r\n    * character, gurantee that this pattern and only this pattern matches.\r\n    *\r\n    * @param {Array} shortcutStylePatterns patterns that always start with\r\n    *   a known character.  Must have a shortcut string.\r\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\r\n    *   order if the shortcut ones fail.  May have shortcuts.\r\n    *\r\n    * @return {function (Object)} a\r\n    *   function that takes source code and returns a list of decorations.\r\n    */\r\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\r\n    var shortcuts = {};\r\n    var tokenizer;\r\n    (function () {\r\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\r\n      var allRegexs = [];\r\n      var regexKeys = {};\r\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\r\n        var patternParts = allPatterns[i];\r\n        var shortcutChars = patternParts[3];\r\n        if (shortcutChars) {\r\n          for (var c = shortcutChars.length; --c >= 0;) {\r\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\r\n          }\r\n        }\r\n        var regex = patternParts[1];\r\n        var k = '' + regex;\r\n        if (!regexKeys.hasOwnProperty(k)) {\r\n          allRegexs.push(regex);\r\n          regexKeys[k] = null;\r\n        }\r\n      }\r\n      allRegexs.push(/[\\0-\\uffff]/);\r\n      tokenizer = combinePrefixPatterns(allRegexs);\r\n    })();\r\n\r\n    var nPatterns = fallthroughStylePatterns.length;\r\n\r\n    /**\r\n     * Lexes job.sourceCode and produces an output array job.decorations of\r\n     * style classes preceded by the position at which they start in\r\n     * job.sourceCode in order.\r\n     *\r\n     * @param {Object} job an object like <pre>{\r\n     *    sourceCode: {string} sourceText plain text,\r\n     *    basePos: {int} position of job.sourceCode in the larger chunk of\r\n     *        sourceCode.\r\n     * }</pre>\r\n     */\r\n    var decorate = function (job) {\r\n      var sourceCode = job.sourceCode, basePos = job.basePos;\r\n      /** Even entries are positions in source in ascending order.  Odd enties\r\n        * are style markers (e.g., PR_COMMENT) that run from that position until\r\n        * the end.\r\n        * @type {Array.<number|string>}\r\n        */\r\n      var decorations = [basePos, PR_PLAIN];\r\n      var pos = 0;  // index into sourceCode\r\n      var tokens = sourceCode.match(tokenizer) || [];\r\n      var styleCache = {};\r\n\r\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\r\n        var token = tokens[ti];\r\n        var style = styleCache[token];\r\n        var match = void 0;\r\n\r\n        var isEmbedded;\r\n        if (typeof style === 'string') {\r\n          isEmbedded = false;\r\n        } else {\r\n          var patternParts = shortcuts[token.charAt(0)];\r\n          if (patternParts) {\r\n            match = token.match(patternParts[1]);\r\n            style = patternParts[0];\r\n          } else {\r\n            for (var i = 0; i < nPatterns; ++i) {\r\n              patternParts = fallthroughStylePatterns[i];\r\n              match = token.match(patternParts[1]);\r\n              if (match) {\r\n                style = patternParts[0];\r\n                break;\r\n              }\r\n            }\r\n\r\n            if (!match) {  // make sure that we make progress\r\n              style = PR_PLAIN;\r\n            }\r\n          }\r\n\r\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\r\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\r\n            isEmbedded = false;\r\n            style = PR_SOURCE;\r\n          }\r\n\r\n          if (!isEmbedded) { styleCache[token] = style; }\r\n        }\r\n\r\n        var tokenStart = pos;\r\n        pos += token.length;\r\n\r\n        if (!isEmbedded) {\r\n          decorations.push(basePos + tokenStart, style);\r\n        } else {  // Treat group 1 as an embedded block of source code.\r\n          var embeddedSource = match[1];\r\n          var embeddedSourceStart = token.indexOf(embeddedSource);\r\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\r\n          if (match[2]) {\r\n            // If embeddedSource can be blank, then it would match at the\r\n            // beginning which would cause us to infinitely recurse on the\r\n            // entire token, so we catch the right context in match[2].\r\n            embeddedSourceEnd = token.length - match[2].length;\r\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\r\n          }\r\n          var lang = style.substring(5);\r\n          // Decorate the left of the embedded source\r\n          appendDecorations(\r\n              basePos + tokenStart,\r\n              token.substring(0, embeddedSourceStart),\r\n              decorate, decorations);\r\n          // Decorate the embedded source\r\n          appendDecorations(\r\n              basePos + tokenStart + embeddedSourceStart,\r\n              embeddedSource,\r\n              langHandlerForExtension(lang, embeddedSource),\r\n              decorations);\r\n          // Decorate the right of the embedded section\r\n          appendDecorations(\r\n              basePos + tokenStart + embeddedSourceEnd,\r\n              token.substring(embeddedSourceEnd),\r\n              decorate, decorations);\r\n        }\r\n      }\r\n      job.decorations = decorations;\r\n    };\r\n    return decorate;\r\n  }\r\n\r\n  /** returns a function that produces a list of decorations from source text.\r\n    *\r\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\r\n    * escape.  It does not recognize perl's qq() style strings.\r\n    * It has no special handling for double delimiter escapes as in basic, or\r\n    * the tripled delimiters used in python, but should work on those regardless\r\n    * although in those cases a single string literal may be broken up into\r\n    * multiple adjacent string literals.\r\n    *\r\n    * It recognizes C, C++, and shell style comments.\r\n    *\r\n    * @param {Object} options a set of optional parameters.\r\n    * @return {function (Object)} a function that examines the source code\r\n    *     in the input job and builds the decoration list.\r\n    */\r\n  function sourceDecorator(options) {\r\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\r\n    if (options['tripleQuotedStrings']) {\r\n      // '''multi-line-string''', 'single-line-string', and double-quoted\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\r\n           null, '\\'\"']);\r\n    } else if (options['multiLineStrings']) {\r\n      // 'multi-line-string', \"multi-line-string\"\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\r\n           null, '\\'\"`']);\r\n    } else {\r\n      // 'single-line-string', \"single-line-string\"\r\n      shortcutStylePatterns.push(\r\n          [PR_STRING,\r\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\r\n           null, '\"\\'']);\r\n    }\r\n    if (options['verbatimStrings']) {\r\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\r\n      fallthroughStylePatterns.push(\r\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\r\n    }\r\n    var hc = options['hashComments'];\r\n    if (hc) {\r\n      if (options['cStyleComments']) {\r\n        if (hc > 1) {  // multiline hash comments\r\n          shortcutStylePatterns.push(\r\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\r\n        } else {\r\n          // Stop C preprocessor declarations at an unclosed open comment\r\n          shortcutStylePatterns.push(\r\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\r\n               null, '#']);\r\n        }\r\n        // #include <stdio.h>\r\n        fallthroughStylePatterns.push(\r\n            [PR_STRING,\r\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\r\n             null]);\r\n      } else {\r\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\r\n      }\r\n    }\r\n    if (options['cStyleComments']) {\r\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\r\n      fallthroughStylePatterns.push(\r\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\r\n    }\r\n    var regexLiterals = options['regexLiterals'];\r\n    if (regexLiterals) {\r\n      /**\r\n       * @const\r\n       */\r\n      var regexExcls = regexLiterals > 1\r\n        ? ''  // Multiline regex literals\r\n        : '\\n\\r';\r\n      /**\r\n       * @const\r\n       */\r\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\r\n      /**\r\n       * @const\r\n       */\r\n      var REGEX_LITERAL = (\r\n          // A regular expression literal starts with a slash that is\r\n          // not followed by * or / so that it is not confused with\r\n          // comments.\r\n          '/(?=[^/*' + regexExcls + '])'\r\n          // and then contains any number of raw characters,\r\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\r\n          // escape sequences (\\x5C),\r\n          +    '|\\\\x5C' + regexAny\r\n          // or non-nesting character sets (\\x5B\\x5D);\r\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\r\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\r\n          // finally closed by a /.\r\n          + '/');\r\n      fallthroughStylePatterns.push(\r\n          ['lang-regex',\r\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\r\n           ]);\r\n    }\r\n\r\n    var types = options['types'];\r\n    if (types) {\r\n      fallthroughStylePatterns.push([PR_TYPE, types]);\r\n    }\r\n\r\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\r\n    if (keywords.length) {\r\n      fallthroughStylePatterns.push(\r\n          [PR_KEYWORD,\r\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\r\n           null]);\r\n    }\r\n\r\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\r\n\r\n    var punctuation =\r\n      // The Bash man page says\r\n\r\n      // A word is a sequence of characters considered as a single\r\n      // unit by GRUB. Words are separated by metacharacters,\r\n      // which are the following plus space, tab, and newline: { }\r\n      // | & $ ; < >\r\n      // ...\r\n      \r\n      // A word beginning with # causes that word and all remaining\r\n      // characters on that line to be ignored.\r\n\r\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\r\n      // comment but empirically\r\n      // $ echo {#}\r\n      // {#}\r\n      // $ echo \\$#\r\n      // $#\r\n      // $ echo }#\r\n      // }#\r\n\r\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\r\n\r\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\r\n      // suggests that this definition is compatible with a\r\n      // default mode that tries to use a single token definition\r\n      // to recognize both bash/python style comments and C\r\n      // preprocessor directives.\r\n\r\n      // This definition of punctuation does not include # in the list of\r\n      // follow-on exclusions, so # will not be broken before if preceeded\r\n      // by a punctuation character.  We could try to exclude # after\r\n      // [|&;<>] but that doesn't seem to cause many major problems.\r\n      // If that does turn out to be a problem, we should change the below\r\n      // when hc is truthy to include # in the run of punctuation characters\r\n      // only when not followint [|&;<>].\r\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\r\n    if (options['regexLiterals']) {\r\n      punctuation += '(?!\\s*\\/)';\r\n    }\r\n\r\n    fallthroughStylePatterns.push(\r\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\r\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\r\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\r\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\r\n        [PR_LITERAL,\r\n         new RegExp(\r\n             '^(?:'\r\n             // A hex number\r\n             + '0x[a-f0-9]+'\r\n             // or an octal or decimal number,\r\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\r\n             // possibly in scientific notation\r\n             + '(?:e[+\\\\-]?\\\\d+)?'\r\n             + ')'\r\n             // with an optional modifier like UL for unsigned long\r\n             + '[a-z]*', 'i'),\r\n         null, '0123456789'],\r\n        // Don't treat escaped quotes in bash as starting strings.\r\n        // See issue 144.\r\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\r\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\r\n\r\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\r\n  }\r\n\r\n  var decorateSource = sourceDecorator({\r\n        'keywords': ALL_KEYWORDS,\r\n        'hashComments': true,\r\n        'cStyleComments': true,\r\n        'multiLineStrings': true,\r\n        'regexLiterals': true\r\n      });\r\n\r\n  /**\r\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\r\n   * list item.\r\n   *\r\n   * @param {Node} node modified in place.  Its content is pulled into an\r\n   *     HTMLOListElement, and each line is moved into a separate list item.\r\n   *     This requires cloning elements, so the input might not have unique\r\n   *     IDs after numbering.\r\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\r\n   *     be treated as significant.\r\n   */\r\n  function numberLines(node, opt_startLineNum, isPreformatted) {\r\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\r\n    var lineBreak = /\\r\\n?|\\n/;\r\n  \r\n    var document = node.ownerDocument;\r\n  \r\n    var li = document.createElement('li');\r\n    while (node.firstChild) {\r\n      li.appendChild(node.firstChild);\r\n    }\r\n    // An array of lines.  We split below, so this is initialized to one\r\n    // un-split line.\r\n    var listItems = [li];\r\n  \r\n    function walk(node) {\r\n      var type = node.nodeType;\r\n      if (type == 1 && !nocode.test(node.className)) {  // Element\r\n        if ('br' === node.nodeName) {\r\n          breakAfter(node);\r\n          // Discard the <BR> since it is now flush against a </LI>.\r\n          if (node.parentNode) {\r\n            node.parentNode.removeChild(node);\r\n          }\r\n        } else {\r\n          for (var child = node.firstChild; child; child = child.nextSibling) {\r\n            walk(child);\r\n          }\r\n        }\r\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\r\n        var text = node.nodeValue;\r\n        var match = text.match(lineBreak);\r\n        if (match) {\r\n          var firstLine = text.substring(0, match.index);\r\n          node.nodeValue = firstLine;\r\n          var tail = text.substring(match.index + match[0].length);\r\n          if (tail) {\r\n            var parent = node.parentNode;\r\n            parent.insertBefore(\r\n              document.createTextNode(tail), node.nextSibling);\r\n          }\r\n          breakAfter(node);\r\n          if (!firstLine) {\r\n            // Don't leave blank text nodes in the DOM.\r\n            node.parentNode.removeChild(node);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Split a line after the given node.\r\n    function breakAfter(lineEndNode) {\r\n      // If there's nothing to the right, then we can skip ending the line\r\n      // here, and move root-wards since splitting just before an end-tag\r\n      // would require us to create a bunch of empty copies.\r\n      while (!lineEndNode.nextSibling) {\r\n        lineEndNode = lineEndNode.parentNode;\r\n        if (!lineEndNode) { return; }\r\n      }\r\n  \r\n      function breakLeftOf(limit, copy) {\r\n        // Clone shallowly if this node needs to be on both sides of the break.\r\n        var rightSide = copy ? limit.cloneNode(false) : limit;\r\n        var parent = limit.parentNode;\r\n        if (parent) {\r\n          // We clone the parent chain.\r\n          // This helps us resurrect important styling elements that cross lines.\r\n          // E.g. in <i>Foo<br>Bar</i>\r\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\r\n          var parentClone = breakLeftOf(parent, 1);\r\n          // Move the clone and everything to the right of the original\r\n          // onto the cloned parent.\r\n          var next = limit.nextSibling;\r\n          parentClone.appendChild(rightSide);\r\n          for (var sibling = next; sibling; sibling = next) {\r\n            next = sibling.nextSibling;\r\n            parentClone.appendChild(sibling);\r\n          }\r\n        }\r\n        return rightSide;\r\n      }\r\n  \r\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\r\n  \r\n      // Walk the parent chain until we reach an unattached LI.\r\n      for (var parent;\r\n           // Check nodeType since IE invents document fragments.\r\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\r\n        copiedListItem = parent;\r\n      }\r\n      // Put it on the list of lines for later processing.\r\n      listItems.push(copiedListItem);\r\n    }\r\n  \r\n    // Split lines while there are lines left to split.\r\n    for (var i = 0;  // Number of lines that have been split so far.\r\n         i < listItems.length;  // length updated by breakAfter calls.\r\n         ++i) {\r\n      walk(listItems[i]);\r\n    }\r\n  \r\n    // Make sure numeric indices show correctly.\r\n    if (opt_startLineNum === (opt_startLineNum|0)) {\r\n      listItems[0].setAttribute('value', opt_startLineNum);\r\n    }\r\n  \r\n    var ol = document.createElement('ol');\r\n    ol.className = 'linenums';\r\n    var offset = Math.max(0, ((opt_startLineNum - 1 /* zero index */)) | 0) || 0;\r\n    for (var i = 0, n = listItems.length; i < n; ++i) {\r\n      li = listItems[i];\r\n      // Stick a class on the LIs so that stylesheets can\r\n      // color odd/even rows, or any other row pattern that\r\n      // is co-prime with 10.\r\n      li.className = 'L' + ((i + offset) % 10);\r\n      if (!li.firstChild) {\r\n        li.appendChild(document.createTextNode('\\xA0'));\r\n      }\r\n      ol.appendChild(li);\r\n    }\r\n  \r\n    node.appendChild(ol);\r\n  }\r\n  /**\r\n   * Breaks {@code job.sourceCode} around style boundaries in\r\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\r\n   * @param {Object} job like <pre>{\r\n   *    sourceCode: {string} source as plain text,\r\n   *    sourceNode: {HTMLElement} the element containing the source,\r\n   *    spans: {Array.<number|Node>} alternating span start indices into source\r\n   *       and the text node or element (e.g. {@code <BR>}) corresponding to that\r\n   *       span.\r\n   *    decorations: {Array.<number|string} an array of style classes preceded\r\n   *       by the position at which they start in job.sourceCode in order\r\n   * }</pre>\r\n   * @private\r\n   */\r\n  function recombineTagsAndDecorations(job) {\r\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\r\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\r\n    var newlineRe = /\\n/g;\r\n  \r\n    var source = job.sourceCode;\r\n    var sourceLength = source.length;\r\n    // Index into source after the last code-unit recombined.\r\n    var sourceIndex = 0;\r\n  \r\n    var spans = job.spans;\r\n    var nSpans = spans.length;\r\n    // Index into spans after the last span which ends at or before sourceIndex.\r\n    var spanIndex = 0;\r\n  \r\n    var decorations = job.decorations;\r\n    var nDecorations = decorations.length;\r\n    // Index into decorations after the last decoration which ends at or before\r\n    // sourceIndex.\r\n    var decorationIndex = 0;\r\n  \r\n    // Remove all zero-length decorations.\r\n    decorations[nDecorations] = sourceLength;\r\n    var decPos, i;\r\n    for (i = decPos = 0; i < nDecorations;) {\r\n      if (decorations[i] !== decorations[i + 2]) {\r\n        decorations[decPos++] = decorations[i++];\r\n        decorations[decPos++] = decorations[i++];\r\n      } else {\r\n        i += 2;\r\n      }\r\n    }\r\n    nDecorations = decPos;\r\n  \r\n    // Simplify decorations.\r\n    for (i = decPos = 0; i < nDecorations;) {\r\n      var startPos = decorations[i];\r\n      // Conflate all adjacent decorations that use the same style.\r\n      var startDec = decorations[i + 1];\r\n      var end = i + 2;\r\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\r\n        end += 2;\r\n      }\r\n      decorations[decPos++] = startPos;\r\n      decorations[decPos++] = startDec;\r\n      i = end;\r\n    }\r\n  \r\n    nDecorations = decorations.length = decPos;\r\n  \r\n    var sourceNode = job.sourceNode;\r\n    var oldDisplay;\r\n    if (sourceNode) {\r\n      oldDisplay = sourceNode.style.display;\r\n      sourceNode.style.display = 'none';\r\n    }\r\n    try {\r\n      var decoration = null;\r\n      while (spanIndex < nSpans) {\r\n        var spanStart = spans[spanIndex];\r\n        var spanEnd = spans[spanIndex + 2] || sourceLength;\r\n  \r\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\r\n  \r\n        var end = Math.min(spanEnd, decEnd);\r\n  \r\n        var textNode = spans[spanIndex + 1];\r\n        var styledText;\r\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\r\n            // Don't introduce spans around empty text nodes.\r\n            && (styledText = source.substring(sourceIndex, end))) {\r\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\r\n          // code to display with spaces instead of line breaks.\r\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\r\n          // space to appear at the beginning of every line but the first.\r\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\r\n          if (isIE8OrEarlier) {\r\n            styledText = styledText.replace(newlineRe, '\\r');\r\n          }\r\n          textNode.nodeValue = styledText;\r\n          var document = textNode.ownerDocument;\r\n          var span = document.createElement('span');\r\n          span.className = decorations[decorationIndex + 1];\r\n          var parentNode = textNode.parentNode;\r\n          parentNode.replaceChild(span, textNode);\r\n          span.appendChild(textNode);\r\n          if (sourceIndex < spanEnd) {  // Split off a text node.\r\n            spans[spanIndex + 1] = textNode\r\n                // TODO: Possibly optimize by using '' if there's no flicker.\r\n                = document.createTextNode(source.substring(end, spanEnd));\r\n            parentNode.insertBefore(textNode, span.nextSibling);\r\n          }\r\n        }\r\n  \r\n        sourceIndex = end;\r\n  \r\n        if (sourceIndex >= spanEnd) {\r\n          spanIndex += 2;\r\n        }\r\n        if (sourceIndex >= decEnd) {\r\n          decorationIndex += 2;\r\n        }\r\n      }\r\n    } finally {\r\n      if (sourceNode) {\r\n        sourceNode.style.display = oldDisplay;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Maps language-specific file extensions to handlers. */\r\n  var langHandlerRegistry = {};\r\n  /** Register a language handler for the given file extensions.\r\n    * @param {function (Object)} handler a function from source code to a list\r\n    *      of decorations.  Takes a single argument job which describes the\r\n    *      state of the computation.   The single parameter has the form\r\n    *      {@code {\r\n    *        sourceCode: {string} as plain text.\r\n    *        decorations: {Array.<number|string>} an array of style classes\r\n    *                     preceded by the position at which they start in\r\n    *                     job.sourceCode in order.\r\n    *                     The language handler should assigned this field.\r\n    *        basePos: {int} the position of source in the larger source chunk.\r\n    *                 All positions in the output decorations array are relative\r\n    *                 to the larger source chunk.\r\n    *      } }\r\n    * @param {Array.<string>} fileExtensions\r\n    */\r\n  function registerLangHandler(handler, fileExtensions) {\r\n    for (var i = fileExtensions.length; --i >= 0;) {\r\n      var ext = fileExtensions[i];\r\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\r\n        langHandlerRegistry[ext] = handler;\r\n      } else if (win['console']) {\r\n        console['warn']('cannot override language handler %s', ext);\r\n      }\r\n    }\r\n  }\r\n  function langHandlerForExtension(extension, source) {\r\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\r\n      // Treat it as markup if the first non whitespace character is a < and\r\n      // the last non-whitespace character is a >.\r\n      extension = /^\\s*</.test(source)\r\n          ? 'default-markup'\r\n          : 'default-code';\r\n    }\r\n    return langHandlerRegistry[extension];\r\n  }\r\n  registerLangHandler(decorateSource, ['default-code']);\r\n  registerLangHandler(\r\n      createSimpleLexer(\r\n          [],\r\n          [\r\n           [PR_PLAIN,       /^[^<?]+/],\r\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\r\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\r\n           // Unescaped content in an unknown language\r\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\r\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\r\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\r\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\r\n           // Unescaped content in javascript.  (Or possibly vbscript).\r\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\r\n           // Contains unescaped stylesheet content\r\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\r\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\r\n          ]),\r\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\r\n  registerLangHandler(\r\n      createSimpleLexer(\r\n          [\r\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\r\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\r\n           ],\r\n          [\r\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\r\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\r\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\r\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\r\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\r\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\r\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\r\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\r\n           ]),\r\n      ['in.tag']);\r\n  registerLangHandler(\r\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': CPP_KEYWORDS,\r\n          'hashComments': true,\r\n          'cStyleComments': true,\r\n          'types': C_TYPES\r\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': 'null,true,false'\r\n        }), ['json']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': CSHARP_KEYWORDS,\r\n          'hashComments': true,\r\n          'cStyleComments': true,\r\n          'verbatimStrings': true,\r\n          'types': C_TYPES\r\n        }), ['cs']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': JAVA_KEYWORDS,\r\n          'cStyleComments': true\r\n        }), ['java']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': SH_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true\r\n        }), ['bash', 'bsh', 'csh', 'sh']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': PYTHON_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'tripleQuotedStrings': true\r\n        }), ['cv', 'py', 'python']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': PERL_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'regexLiterals': 2  // multiline regex literals\r\n        }), ['perl', 'pl', 'pm']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': RUBY_KEYWORDS,\r\n          'hashComments': true,\r\n          'multiLineStrings': true,\r\n          'regexLiterals': true\r\n        }), ['rb', 'ruby']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': JSCRIPT_KEYWORDS,\r\n          'cStyleComments': true,\r\n          'regexLiterals': true\r\n        }), ['javascript', 'js']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': COFFEE_KEYWORDS,\r\n          'hashComments': 3,  // ### style block comments\r\n          'cStyleComments': true,\r\n          'multilineStrings': true,\r\n          'tripleQuotedStrings': true,\r\n          'regexLiterals': true\r\n        }), ['coffee']);\r\n  registerLangHandler(sourceDecorator({\r\n          'keywords': RUST_KEYWORDS,\r\n          'cStyleComments': true,\r\n          'multilineStrings': true\r\n        }), ['rc', 'rs', 'rust']);\r\n  registerLangHandler(\r\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\r\n\r\n  function applyDecorator(job) {\r\n    var opt_langExtension = job.langExtension;\r\n\r\n    try {\r\n      // Extract tags, and convert the source code to plain text.\r\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\r\n      /** Plain text. @type {string} */\r\n      var source = sourceAndSpans.sourceCode;\r\n      job.sourceCode = source;\r\n      job.spans = sourceAndSpans.spans;\r\n      job.basePos = 0;\r\n\r\n      // Apply the appropriate language handler\r\n      langHandlerForExtension(opt_langExtension, source)(job);\r\n\r\n      // Integrate the decorations and tags back into the source code,\r\n      // modifying the sourceNode in place.\r\n      recombineTagsAndDecorations(job);\r\n    } catch (e) {\r\n      if (win['console']) {\r\n        console['log'](e && e['stack'] || e);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Pretty print a chunk of code.\r\n   * @param sourceCodeHtml {string} The HTML to pretty print.\r\n   * @param opt_langExtension {string} The language name to use.\r\n   *     Typically, a filename extension like 'cpp' or 'java'.\r\n   * @param opt_numberLines {number|boolean} True to number lines,\r\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\r\n   */\r\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\r\n    var container = document.createElement('div');\r\n    // This could cause images to load and onload listeners to fire.\r\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\r\n    // We assume that the inner HTML is from a trusted source.\r\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\r\n    // when it is injected into a <pre> tag.\r\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\r\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\r\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\r\n    container = container.firstChild;\r\n    if (opt_numberLines) {\r\n      numberLines(container, opt_numberLines, true);\r\n    }\r\n\r\n    var job = {\r\n      langExtension: opt_langExtension,\r\n      numberLines: opt_numberLines,\r\n      sourceNode: container,\r\n      pre: 1\r\n    };\r\n    applyDecorator(job);\r\n    return container.innerHTML;\r\n  }\r\n\r\n   /**\r\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\r\n    * {@code class=prettyprint} and prettify them.\r\n    *\r\n    * @param {Function} opt_whenDone called when prettifying is done.\r\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\r\n    *   containing all the elements to pretty print.\r\n    *   Defaults to {@code document.body}.\r\n    */\r\n  function $prettyPrint(opt_whenDone, opt_root) {\r\n    var root = opt_root || document.body;\r\n    var doc = root.ownerDocument || document;\r\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\r\n    // fetch a list of nodes to rewrite\r\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\r\n    var elements = [];\r\n    for (var i = 0; i < codeSegments.length; ++i) {\r\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\r\n        elements.push(codeSegments[i][j]);\r\n      }\r\n    }\r\n    codeSegments = null;\r\n\r\n    var clock = Date;\r\n    if (!clock['now']) {\r\n      clock = { 'now': function () { return +(new Date); } };\r\n    }\r\n\r\n    // The loop is broken into a series of continuations to make sure that we\r\n    // don't make the browser unresponsive when rewriting a large page.\r\n    var k = 0;\r\n    var prettyPrintingJob;\r\n\r\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\r\n    var prettyPrintRe = /\\bprettyprint\\b/;\r\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\r\n    var preformattedTagNameRe = /pre|xmp/i;\r\n    var codeRe = /^code$/i;\r\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\r\n    var EMPTY = {};\r\n\r\n    function doWork() {\r\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\r\n                     clock['now']() + 250 /* ms */ :\r\n                     Infinity);\r\n      for (; k < elements.length && clock['now']() < endTime; k++) {\r\n        var cs = elements[k];\r\n\r\n        // Look for a preceding comment like\r\n        // <?prettify lang=\"...\" linenums=\"...\"?>\r\n        var attrs = EMPTY;\r\n        {\r\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\r\n            var nt = preceder.nodeType;\r\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\r\n            // like <!--?foo?-->, but in XML is a processing instruction\r\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\r\n            if (value\r\n                ? !/^\\??prettify\\b/.test(value)\r\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\r\n              // Skip over white-space text nodes but not others.\r\n              break;\r\n            }\r\n            if (value) {\r\n              attrs = {};\r\n              value.replace(\r\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\r\n                function (_, name, value) { attrs[name] = value; });\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        var className = cs.className;\r\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\r\n            // Don't redo this if we've already done it.\r\n            // This allows recalling pretty print to just prettyprint elements\r\n            // that have been added to the page since last call.\r\n            && !prettyPrintedRe.test(className)) {\r\n\r\n          // make sure this is not nested in an already prettified element\r\n          var nested = false;\r\n          for (var p = cs.parentNode; p; p = p.parentNode) {\r\n            var tn = p.tagName;\r\n            if (preCodeXmpRe.test(tn)\r\n                && p.className && prettyPrintRe.test(p.className)) {\r\n              nested = true;\r\n              break;\r\n            }\r\n          }\r\n          if (!nested) {\r\n            // Mark done.  If we fail to prettyprint for whatever reason,\r\n            // we shouldn't try again.\r\n            cs.className += ' prettyprinted';\r\n\r\n            // If the classes includes a language extensions, use it.\r\n            // Language extensions can be specified like\r\n            //     <pre class=\"prettyprint lang-cpp\">\r\n            // the language extension \"cpp\" is used to find a language handler\r\n            // as passed to PR.registerLangHandler.\r\n            // HTML5 recommends that a language be specified using \"language-\"\r\n            // as the prefix instead.  Google Code Prettify supports both.\r\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\r\n            var langExtension = attrs['lang'];\r\n            if (!langExtension) {\r\n              langExtension = className.match(langExtensionRe);\r\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\r\n              var wrapper;\r\n              if (!langExtension && (wrapper = childContentWrapper(cs))\r\n                  && codeRe.test(wrapper.tagName)) {\r\n                langExtension = wrapper.className.match(langExtensionRe);\r\n              }\r\n\r\n              if (langExtension) { langExtension = langExtension[1]; }\r\n            }\r\n\r\n            var preformatted;\r\n            if (preformattedTagNameRe.test(cs.tagName)) {\r\n              preformatted = 1;\r\n            } else {\r\n              var currentStyle = cs['currentStyle'];\r\n              var defaultView = doc.defaultView;\r\n              var whitespace = (\r\n                  currentStyle\r\n                  ? currentStyle['whiteSpace']\r\n                  : (defaultView\r\n                     && defaultView.getComputedStyle)\r\n                  ? defaultView.getComputedStyle(cs, null)\r\n                  .getPropertyValue('white-space')\r\n                  : 0);\r\n              preformatted = whitespace\r\n                  && 'pre' === whitespace.substring(0, 3);\r\n            }\r\n\r\n            // Look for a class like linenums or linenums:<n> where <n> is the\r\n            // 1-indexed number of the first line.\r\n            var lineNums = attrs['linenums'];\r\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\r\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\r\n              lineNums =\r\n                lineNums\r\n                ? lineNums[1] && lineNums[1].length\r\n                  ? +lineNums[1] : true\r\n                : false;\r\n            }\r\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\r\n\r\n            // do the pretty printing\r\n            prettyPrintingJob = {\r\n              langExtension: langExtension,\r\n              sourceNode: cs,\r\n              numberLines: lineNums,\r\n              pre: preformatted\r\n            };\r\n            applyDecorator(prettyPrintingJob);\r\n          }\r\n        }\r\n      }\r\n      if (k < elements.length) {\r\n        // finish up in a continuation\r\n        setTimeout(doWork, 250);\r\n      } else if ('function' === typeof opt_whenDone) {\r\n        opt_whenDone();\r\n      }\r\n    }\r\n\r\n    doWork();\r\n  }\r\n\r\n  /**\r\n   * Contains functions for creating and registering new language handlers.\r\n   * @type {Object}\r\n   */\r\n  var PR = win['PR'] = {\r\n        'createSimpleLexer': createSimpleLexer,\r\n        'registerLangHandler': registerLangHandler,\r\n        'sourceDecorator': sourceDecorator,\r\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\r\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\r\n        'PR_COMMENT': PR_COMMENT,\r\n        'PR_DECLARATION': PR_DECLARATION,\r\n        'PR_KEYWORD': PR_KEYWORD,\r\n        'PR_LITERAL': PR_LITERAL,\r\n        'PR_NOCODE': PR_NOCODE,\r\n        'PR_PLAIN': PR_PLAIN,\r\n        'PR_PUNCTUATION': PR_PUNCTUATION,\r\n        'PR_SOURCE': PR_SOURCE,\r\n        'PR_STRING': PR_STRING,\r\n        'PR_TAG': PR_TAG,\r\n        'PR_TYPE': PR_TYPE,\r\n        'prettyPrintOne':\r\n           IN_GLOBAL_SCOPE\r\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\r\n             : (prettyPrintOne = $prettyPrintOne),\r\n        'prettyPrint': prettyPrint =\r\n           IN_GLOBAL_SCOPE\r\n             ? (win['prettyPrint'] = $prettyPrint)\r\n             : (prettyPrint = $prettyPrint)\r\n      };\r\n\r\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\r\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\r\n  // The Asynchronous Module Definition (AMD) API specifies a\r\n  // mechanism for defining modules such that the module and its\r\n  // dependencies can be asynchronously loaded.\r\n  // ...\r\n  // To allow a clear indicator that a global define function (as\r\n  // needed for script src browser loading) conforms to the AMD API,\r\n  // any global define function SHOULD have a property called \"amd\"\r\n  // whose value is an object. This helps avoid conflict with any\r\n  // other existing JavaScript code that could have defined a define()\r\n  // function that does not conform to the AMD API.\r\n  if (typeof define === \"function\" && define['amd']) {\r\n    define(\"google-code-prettify\", [], function () {\r\n      return PR; \r\n    });\r\n  }\r\n})();\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/sample-codes/app/config.js":"(function () {\r\n    'use strict';\r\n\r\n    angular\r\n    .module('app')\r\n    .config(stateConfig)\r\n\r\n   /**\r\n    * Configures ui-router's states.\r\n    * @memberof app\r\n    * @ngdoc config\r\n    * @name config\r\n    * @param {Service} $urlRouterProvider Watches $location and provides interface to default state\r\n    */\r\n\r\n    function stateConfig($urlRouterProvider) {\r\n        $urlRouterProvider.otherwise('/search')\r\n    }\r\n})();\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/sample-codes/app/custom-currency.js":"/**\r\n * The siteLanguageServices provides information about available languges\r\n * of a site.\r\n *\r\n * @memberof app\r\n * @ngdoc filter\r\n * @name customCurrency\r\n * @param {$http} Test\r\n * @desc\r\n *  returns custom currency from the given input\r\n * @tutorial tutorial1\r\n */\r\n(function() {\r\n  'use strict';\r\n  var customCurrency = function($http) { \r\n\r\n\r\n    /**\r\n     * @func customCurrencyFilter\r\n     * @memberof customCurrency\r\n     * @desc\r\n     *  . Create the return function and set the required parameter name to **input**\r\n     *  . setup optional parameters for the currency symbol and location (left or right of the amount)\r\n     * @param {Number|String} input\r\n     * @param {String} symbol\r\n     * @param {Boolean} place  true or false\r\n     */\r\n    return function(input, symbol, place) {\r\n\r\n      // Ensure that we are working with a number\r\n      if(isNaN(input)) {\r\n        return input;\r\n      } else {\r\n\r\n        // Check if optional parameters are passed, if not, use the defaults\r\n        var symbol = symbol || '$';\r\n        var place = place === undefined ? true : place;\r\n\r\n        // Perform the operation to set the symbol in the right location\r\n        if( place === true) {\r\n          return symbol + input;\r\n        } else {\r\n          return input + symbol;\r\n        }\r\n\r\n      }\r\n    }\r\n  };\r\n\r\n  angular.module('app').filter('customCurrency', customCurrency);\r\n})();\r\n\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/sample-codes/ngmap/attr2-options.js":"(function() {\r\n  'use strict';\r\n\r\n  /**\r\n   * @memberof ngmap\r\n   * @ngdoc service\r\n   * @name Attr2Options\r\n   * @param {service} $parse angular html parser\r\n   * @param {service} $timeout angular window.setTimeout service\r\n   * @param {service} NavigatorGeolocation Google NavigatorGeolocation wrapper\r\n   * @param {service} GeoCoder Google GeoCoder wrapper\r\n   * @description \r\n   *   Converts html attributes to google api v3 object options\r\n   */\r\n  var Attr2Options = function($parse, $timeout, NavigatorGeolocation, GeoCoder) { \r\n\r\n    /**\r\n     * Convert input to Google Map option input\r\n     * @memberof Attr2Options\r\n     * @param {Objec} input a value to convert\r\n     * @param {Hash} options to convert the input\r\n     * @returns {Hash} attributes\r\n     */\r\n    var toOptionValue = function(input, options) {\r\n      // .. code ..\r\n    };\r\n\r\n    /**\r\n     * filters attributes by skipping angularjs methods $.. $$..\r\n     * @memberof Attr2Options\r\n     * @param {Hash} attrs tag attributes\r\n     * @returns {Hash} filterd attributes\r\n     */\r\n    var filter = function(attrs) {\r\n      // .. code ..\r\n    };\r\n\r\n    /**\r\n     * converts attributes hash to Google Maps API v3 options  \r\n     * ```\r\n     *  . converts numbers to number   \r\n     *  . converts class-like string to google maps instance   \r\n     *    i.e. `LatLng(1,1)` to `new google.maps.LatLng(1,1)`  \r\n     *  . converts constant-like string to google maps constant    \r\n     *    i.e. `MapTypeId.HYBRID` to `google.maps.MapTypeId.HYBRID`   \r\n     *    i.e. `HYBRID\"` to `google.maps.MapTypeId.HYBRID`  \r\n     * ```\r\n     * @memberof Attr2Options\r\n     * @param {Hash} attrs tag attributes\r\n     * @param {scope} scope angularjs scope\r\n     * @returns {Hash} options converted attributess\r\n     */\r\n    var getOptions = function(attrs, scope) {\r\n      // .. code ..\r\n    };\r\n\r\n    /**\r\n     * converts attributes hash to scope-specific event function \r\n     * @memberof Attr2Options\r\n     * @param {scope} scope angularjs scope\r\n     * @param {Hash} attrs tag attributes\r\n     * @returns {Hash} events converted events\r\n     */\r\n    var getEvents = function(scope, attrs) {\r\n      // .. code ..\r\n    };\r\n\r\n    /**\r\n     * Return options of Google map control, i.e streetview, pan, etc, not a general control\r\n     * @memberof Attr2Options\r\n     * @param {Hash} filtered filtered tag attributes\r\n     * @returns {Hash} Google Map options\r\n     */\r\n    var getControlOptions = function(filtered) {\r\n      // .. code ..\r\n    };\r\n\r\n    return {\r\n      filter: filter,\r\n      getOptions: getOptions,\r\n      getEvents: getEvents,\r\n      getControlOptions: getControlOptions,\r\n      toOptionValue: toOptionValue,\r\n      orgAttributes: orgAttributes\r\n    }; // return\r\n\r\n  }; \r\n\r\n  angular.module('ngMap').service('Attr2Options', Attr2Options);\r\n})();\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/sample-codes/ngmap/map-controller.js":"(function() {\r\n  'use strict';\r\n\r\n  /**\r\n   * @memberof ngmap\r\n   * @ngdoc controller\r\n   * @name MapController\r\n   * @param $scope {service} controller scope\r\n   * @param $q {service} promise service\r\n   * @param NavigatorGeolocation {service} Google NavigatorGeolocation wrapper\r\n   * @param GeoCoder {service} Google GeoCoder wrapper\r\n   * @param Attr2Options {service} Converts element attributes to Google Maps API options\r\n   */\r\n  var MapController = function($scope, $q, NavigatorGeolocation, GeoCoder, Attr2Options) { \r\n\r\n    /**\r\n     * @property {Hash} _objects collection og objects that belongs to this map\r\n     */\r\n    this._objects = {};\r\n\r\n    /**\r\n     * Add an object to the collection of group\r\n     * @memberof MapController\r\n     * @function addObject\r\n     * @param groupName the name of collection that object belongs to\r\n     * @param obj  an object to add into a collection, i.e. marker, shape\r\n     */\r\n    this.addObject = function(groupName, obj) {\r\n      // .. code ..\r\n    };\r\n\r\n    /**\r\n     * Delete an object from the collection and remove from map\r\n     * @memberof MapController\r\n     * @function deleteObject\r\n     * @param {Array} objs the collection of objects. i.e., map.markers\r\n     * @param {Object} obj the object to be removed. i.e., marker\r\n     */\r\n    this.deleteObject = function(groupName, obj) {\r\n      // .. code ..\r\n    };\r\n\r\n    /**\r\n     * returns the location of an address or 'current-location'\r\n     * @memberof MapController\r\n     * @function getGeoLocation\r\n     * @param {String} string an address to find the location\r\n     * @returns {Promise} latlng the location of the address\r\n     */\r\n    this.getGeoLocation = function(string) {\r\n      // .. code ..\r\n    };\r\n\r\n  };\r\n\r\n  angular.module('ngMap').controller('MapController', MapController);\r\n})();\r\n","/home/travis/build/npmtest/node-npmtest-angular-jsdoc/node_modules/angular-jsdoc/sample-codes/ngmap/map.js":"(function () {\r\n  'use strict';\r\n\r\n  /**\r\n   * @memberof ngmap\r\n   * @ngdoc directive\r\n   * @name map\r\n   * @param  {service} Attr2Options Converts html attributes to Google map options\r\n   * @param  {service} $timeout     Angular window.setTimeout wrapper \r\n   * @param  {service} $parse       Angular html parser\r\n   * @description\r\n   *   Implementation of MapController\r\n   *   Initialize a Google map within a `<div>` tag with given options and register events\r\n   *   It accepts children directives; marker, shape, or marker-clusterer\r\n   *\r\n   *   It initialize map, children tags, then emits message as soon as the action is done\r\n   *   The message emitted from this directive is;\r\n   *     . mapInitialized\r\n   *\r\n   * @attr {Expression} geo-callback \r\n   *    If center is an address or current location, the expression is will be executed \r\n   *    when geo-lookup is successful. e.g., geo-callback=\"showMyStoreInfo()\"\r\n   * @attr {Array} geo-fallback-center  The center of map incase geolocation failed. i.e. [0,0]\r\n   * @attr {Boolean} zoom-to-include-markers\r\n   *    If true, map boundary will be changed automatially to include all markers when initialized\r\n   * @attr {Boolean} default-style\r\n   *    When false, the default styling, `display:block;height:300px`, will be ignored.\r\n   * @attr {String} init-event The name of event to initialize this map.\r\n   *    If this option is given, the map won't be initialized until the event is received.\r\n   *    To invoke the event, use $scope.$emit or $scope.$broacast.\r\n   *    i.e. `<map init-event=\"init-map\" ng-click=\"$emit('init-map')\" center=... ></map>`\r\n   * @attr {String} &lt;MapOption> [Any Google map options](https://developers.google.com/maps/documentation/javascript/reference?csw=1#MapOptions)\r\n   * @attr {String} &lt;MapEvent> [Any Google map events](https://rawgit.com/allenhwkim/angularjs-google-maps/master/build/map_events.html)\r\n   * @example\r\n   *   Usage:\r\n   *   <map MAP_OPTIONS_OR_MAP_EVENTS ..>\r\n   *     ... Any children directives\r\n   *   </map>\r\n   *\r\n   *   <map center=\"[40.74, -74.18]\" on-click=\"doThat()\">\r\n   *   </map>\r\n   *\r\n   *   <map geo-fallback-center=\"[40.74, -74.18]\" zoom-to-inlude-markers=\"true\">\r\n   *   </map>\r\n   */\r\n  var map = function(Attr2Options, $timeout, $parse) {\r\n\r\n    /**\r\n     * Initialize map and events\r\n     * @memberof map\r\n     * @param {service} scope the scope of this element\r\n     * @param {service} element element that this direcive is assigned to\r\n     * @param {service}   attrs attribute of this element\r\n     * @param {MapController} ctrl map controller\r\n     */\r\n    var linkFunc = function (scope, element, attrs, ctrl) {\r\n      // .. code ..\r\n    };\r\n\r\n    return {\r\n      restrict: 'AE',\r\n      controller: 'MapController',\r\n      link: linkFunc,\r\n      templateUrl: 'sample-codes/ngmap/test-template.html'\r\n    };\r\n  };\r\n\r\n  angular.module('ngMap').directive('map', map);\r\n})();\r\n"}